{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/auth-models/chip/SECP256k1Model.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/**\n * @title SECP256k1Model\n * @author Arx\n *\n * @notice Auth model contract that encodes an implementation of the curve used to sign chip messages. These\n * contracts are referred to by Manufacturer's when they enroll chips in the ManufacturerRegistry so that chip\n * holders know the curve used to sign messages from the chip. Chip holders can validate chip signatures against\n * this contract using the `verify` function. This auth model specifically uses the SECP256k1 curve native to\n * Ethereum.\n */\ncontract SECP256k1Model {\n    using ECDSA for bytes32;\n\n    /**\n     * @notice Verifies a signature against a message and signer address\n     * @param _message      The message that was signed\n     * @param _signature    The signature to verify\n     * @param _signer       The address that signed the message\n     * @return bool         True if the signature is valid, false otherwise\n     */\n    function verify(\n        bytes32 _message,\n        bytes memory _signature,\n        address _signer\n    ) public pure returns (bool) {\n        return _message.recover(_signature) == _signer;\n    }\n}\n"
    },
    "contracts/auth-models/enrollment/EnrollmentEIP191Model.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport { IEnrollmentAuthModel } from \"../../interfaces/IEnrollmentAuthModel.sol\";\n\n/**\n * @title EnrollmentEIP191Model\n * @author Arx\n *\n * @notice Enrollment Auth model contract that encodes an implementation of the curve used to sign manufacturer \n * enrollment messages.\n */\ncontract EnrollmentEIP191Model is IEnrollmentAuthModel {\n\n    using SignatureChecker for address;\n    using ECDSA for bytes;\n \n    constructor() {}\n\n    /**\n     * @notice Verifies a signature against a message and signer address\n     * @param _chipId The address of the chip\n     * @param _manufacturerCertSigner The address of the signer\n     * @param _manufacturerCertificate The manufacturer certificate\n     * Optional: Additional payload if required for authnetication; optional\n     */\n    function verifyManufacturerCertificate(\n        address _chipId,\n        address _manufacturerCertSigner,\n        bytes calldata _manufacturerCertificate,\n        bytes calldata\n    )\n        external\n        view\n        returns (bool)\n    {\n        bytes32 messageHash = abi.encodePacked(_chipId).toEthSignedMessageHash();\n        return _manufacturerCertSigner.isValidSignatureNow(messageHash, _manufacturerCertificate);\n    }\n}\n"
    },
    "contracts/auth-models/enrollment/EnrollmentSECP256k1Model.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport { IEnrollmentAuthModel } from \"../../interfaces/IEnrollmentAuthModel.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\n/**\n * @title EnrollmentSECP256k1Model\n * @author Arx\n *\n * @notice Enrollment Auth model contract that encodes an implementation of the curve used to sign manufacturer \n * enrollment messages.\n */\ncontract EnrollmentSECP256k1Model is EIP712, IEnrollmentAuthModel {\n\n    using SignatureChecker for address;\n    using ECDSA for bytes32;\n\n    /* ============ Constants ============ */\n    // Match signature version to project version.\n    string public constant EIP712_SIGNATURE_DOMAIN = \"ERS\";\n    string public constant EIP712_SIGNATURE_VERSION = \"2.0.0\";\n\n    /* ============ Constructor ============ */\n    /**\n     * @dev Constructor for EnrollmentSECP256k1Model. Sets the owner and EIP712 domain.\n     */   \n    constructor() \n        EIP712(EIP712_SIGNATURE_DOMAIN, EIP712_SIGNATURE_VERSION) \n    {}\n\n    /**\n     * @notice Verifies a signature against a message and signer address\n     * @param _chipId The address of the chip\n     * @param _manufacturerCertSigner The address of the signer\n     * @param _manufacturerCertificate The manufacturer certificate\n     * Optional: Additional payload if required for authnetication; optional\n     */\n    function verifyManufacturerCertificate(\n        address _chipId,\n        address _manufacturerCertSigner,\n        bytes calldata _manufacturerCertificate,\n        bytes calldata\n    )\n        external\n        view\n        returns (bool)\n    {\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n            keccak256(\"ManufacturerCertificate(address chipId)\"),\n            _chipId\n        )));\n\n        return _manufacturerCertSigner.isValidSignatureNow(digest, _manufacturerCertificate);\n    }\n}\n"
    },
    "contracts/ChipRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport { StringArrayUtils } from \"./lib/StringArrayUtils.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\nimport { IChipRegistry } from \"./interfaces/IChipRegistry.sol\";\nimport { IERS } from \"./interfaces/IERS.sol\";\nimport { IManufacturerRegistry } from \"./interfaces/IManufacturerRegistry.sol\";\nimport { IServicesRegistry } from \"./interfaces/IServicesRegistry.sol\";\nimport { IDeveloperRegistry } from \"./interfaces/IDeveloperRegistry.sol\";\nimport { IDeveloperRegistrar } from \"./interfaces/IDeveloperRegistrar.sol\";\nimport { IProjectRegistrar } from \"./interfaces/IProjectRegistrar.sol\";\n\n/**\n * @title ChipRegistry\n * @author Arx\n *\n * @notice Entrypoint for resolving chips added to ERS Protocol. Developers can enroll new projects into this registry by \n * specifying a ProjectRegistrar to manage chip additions. Chip additions are forwarded from ProjectRegistrars that typically \n * mint an ERC-721 compliant \"token\" of the chip to the claimant and other metadata associated with the chip is set. \n * Any project looking to integrate ERS chips should get resolution information about chips from this address. Because \n * chips are represented as tokens any physical chip transfers should also be completed on-chain in order to get full \n * functionality for the chip.\n */\ncontract ChipRegistry is Ownable2Step, ERC165, EIP712 {\n    using SignatureChecker for address;\n    using ECDSA for bytes;\n    using StringArrayUtils for string[];\n\n    /* ============ Events ============ */\n\n    event ProjectEnrollmentAdded(                  // Emitted during addProjectEnrollment\n        address indexed developerRegistrar,\n        address indexed projectRegistrar,\n        bytes32 nameHash,\n        address servicesRegistry,\n        bytes32 serviceId\n    );\n\n    event ProjectEnrollmentRemoved(                // Emitted during removeProjectEnrollment\n        address indexed developerRegistrar,\n        address indexed projectRegistrar,\n        bytes32 nameHash\n    );\n\n    event ChipAdded(                              // Emitted during addChip\n        address indexed chipId,\n        address indexed projectRegistrar,\n        bytes32 indexed manufacturerEnrollmentId,\n        address owner,\n        bytes32 serviceId,\n        bytes32 ersNode,\n        bool    hasDeveloperCustodyProof\n        \n    );\n\n    event MaxLockinPeriodUpdated(uint256 maxLockinPeriod);  // Emitted during updateMaxLockinPeriod\n    event MigrationSignerUpdated(address migrationSigner);  // Emitted during updateMigrationSigner\n    event RegistryInitialized(                              // Emitted during initialize\n        address ers,\n        address developerRegistry\n    );\n\n    /* ============ Structs ============ */\n\n    // Do we need an identifier to replace the merkle root? nodehash?\n    struct ProjectInfo {\n        bytes32 nameHash;\n        IDeveloperRegistrar developerRegistrar;\n        IServicesRegistry servicesRegistry;\n        bool chipsAdded;\n        bytes32 serviceId;\n        uint256 lockinPeriod;\n        uint256 creationTimestamp;\n    }\n\n    struct ChipInfo {\n        bytes32 nameHash;\n        address projectRegistrar; // projectRegistrars are IProjectRegistrar and typically assumed to be IPBT\n        bytes32 manufacturerEnrollmentId;     // enrollmentId of the chip's manufacturer\n        bool chipEnrolled;\n    }\n\n    /* ============ Constants ============ */\n    // Match signature version to project version.\n    string public constant EIP712_SIGNATURE_DOMAIN = \"ERS\";\n    string public constant EIP712_SIGNATURE_VERSION = \"2.0.0\";\n\n    /* ============ State Variables ============ */\n    IManufacturerRegistry public immutable manufacturerRegistry;\n    IERS public ers;\n    IDeveloperRegistry public developerRegistry;\n    bool public initialized;\n    address public migrationSigner;\n\n    mapping(IProjectRegistrar => ProjectInfo) public projectEnrollments;  // Maps ProjectRegistrar addresses to ProjectInfo\n    mapping(address => ChipInfo) public chipEnrollments;                  // Maps chipId to ChipInfo\n    uint256 public maxLockinPeriod;                                       // Max amount of time chips can be locked into a service after a\n                                                                          // project's creation timestamp\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructor for ChipRegistry\n     *\n     * @param _manufacturerRegistry     Address of the ManufacturerRegistry contract\n     * @param _maxLockinPeriod          The maximum amount of time a chip can be locked into a service for beyond the project's creation timestamp\n    */\n    constructor(\n        IManufacturerRegistry _manufacturerRegistry,\n        uint256 _maxLockinPeriod,\n        address _migrationSigner\n    )\n        Ownable2Step()\n        EIP712(EIP712_SIGNATURE_DOMAIN, EIP712_SIGNATURE_VERSION) \n    {\n        require(address(_manufacturerRegistry) != address(0), \"Invalid manufacturer registry address\");\n        require(_maxLockinPeriod <= 315569520, \"maxLockinPeriod cannot exceed 10 years\");\n        require(_migrationSigner != address(0), \"Invalid migration signer address\");\n\n        manufacturerRegistry = _manufacturerRegistry;\n        maxLockinPeriod = _maxLockinPeriod;\n        migrationSigner = _migrationSigner;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @dev ONLY Developer REGISTRAR: Enroll new project in ChipRegistry. This function is only callable by DeveloperRegistrars. In order to use\n     * this function the project must first sign a message of the _projectRegistrar address with the _projectPublicKey's matching\n     * private key. This key MUST be the same key used to sign all the chip certificates for the project. This creates a link between\n     * chip certificates (which may be posted online) and the deployer of the registrar hence making sure that no malicious Developer is able\n     * to steal another Developer's chips for their own enrollment (unless the private key happens to be leaked). This function will\n     * revert if the project is already enrolled. See documentation for more instructions on how to create a project merkle root.\n     *\n     * @param _projectRegistrar         Address of the ProjectRegistrar contract\n     * @param _nameHash                 Label of the project's node in the ERS tree\n     * @param _servicesRegistry         Address of the ServicesRegistry contract for the project\n     * @param _serviceId                The serviceId of the project's preferred service\n     * @param _lockinPeriod             The amount of time a chip can be locked into a service for beyond the project's creation timestamp\n     */\n\n    function addProjectEnrollment(\n        IProjectRegistrar _projectRegistrar,\n        bytes32 _nameHash,\n        IServicesRegistry _servicesRegistry,\n        bytes32 _serviceId,\n        uint256 _lockinPeriod\n    )\n        external\n    {\n        require(developerRegistry.isDeveloperRegistrar(msg.sender), \"Must be Developer Registrar\");\n        require(address(_projectRegistrar) != address(0), \"Invalid project registrar address\");\n\n        // Verify that the project registrar implements the necessary interfaces\n        IERC165 checker = IERC165(address(_projectRegistrar));\n        require(checker.supportsInterface(type(IProjectRegistrar).interfaceId), \"Does not implement IProjectRegistrar\");\n\n        // Verify that the project isn't already enrolled\n        require(projectEnrollments[_projectRegistrar].creationTimestamp == 0, \"Project already enrolled\");\n\n        // Verify that the services registry implements the necessary interfaces\n        require(IERC165(address(_servicesRegistry)).supportsInterface(type(IServicesRegistry).interfaceId), \"Does not implement IServicesRegistry\");\n\n        // Look up the _serviceId to ensure it exists.\n        require(_servicesRegistry.isService(_serviceId), \"Service does not exist\");\n\n        projectEnrollments[_projectRegistrar] = ProjectInfo({\n            nameHash: _nameHash,\n            developerRegistrar: IDeveloperRegistrar(msg.sender),\n            servicesRegistry: _servicesRegistry,\n            serviceId: _serviceId,\n            lockinPeriod: _lockinPeriod,\n            creationTimestamp: block.timestamp,\n            chipsAdded: false\n        });\n\n        emit ProjectEnrollmentAdded(\n            msg.sender,\n            address(_projectRegistrar),\n            _nameHash,\n            address(_servicesRegistry),\n            _serviceId\n        );\n    }\n\n    /**\n     * @notice Allow a project to add chips. Enrollment allows the chip to resolve to the project's preferred\n     * service. Additionally, claiming creates a Physically-Bound Token representation of the chip.\n     *\n     * @dev This function will revert if the chip has already been added, if invalid certificate data is provided or if the chip is\n     * not part of the project enrollment (not in the project merkle root). Addtionally, there are checks to ensure that the calling\n     * ProjectRegistrar has implemented the correct ERS logic. This function is EIP-1271 compatible and can be used to verify chip\n     * claims tied to an account contract.\n     *\n     * @param _chipId                       Chip ID (address)\n     * @param _chipOwner                    Struct containing information for validating merkle proof, chip owner, and chip's ERS node\n     * @param _nameHash                     Label of the node in the ERS tree; typically the chipId unless the project wishes to use \n     *                                      another unique identifier. The full ersNode will be used as the tokenId for the issued PBT.\n     * @param _manufacturerValidation       Struct containing information for chip's inclusion in manufacturer's merkle tree\n     * @param _custodyProof                 Proof of chip custody by the developer; this can also be a migration proof\n     */\n    function addChip(\n        address _chipId,\n        address _chipOwner,\n        bytes32 _nameHash,\n        IChipRegistry.ManufacturerValidation memory _manufacturerValidation,\n        bytes memory _custodyProof\n    )\n        external\n        virtual\n    {\n        IProjectRegistrar projectRegistrar = IProjectRegistrar(msg.sender);\n        ProjectInfo memory projectInfo = projectEnrollments[projectRegistrar];\n\n        // Verify the chip owner is set to non-zero address\n        require(_chipId != address(0), \"Invalid chip\");\n    \n        // Verify the chip owner is set to non-zero address\n        require(_chipOwner != address(0), \"Invalid chip owner\");\n\n        // Verify the chip is being added by an enrolled project\n        require(projectInfo.creationTimestamp != 0, \"ChipRegistry: Project not enrolled\");\n\n        // Verify that the chip doesn't exist yet\n        require(!chipEnrollments[_chipId].chipEnrolled, \"Chip already added\");\n        \n        // Validate the manufacturer certificate\n        _validateManufacturerCertificate(_chipId, _manufacturerValidation);\n\n        // Validate the custody proof and determine if it is a developer custody proof or migration proof; will revert if invalid proof for both cases\n        bool hasDeveloperCustodyProof = _isDeveloperCustodyProofAndValid(_chipId, address(projectInfo.developerRegistrar), _custodyProof);\n\n        // Create the chip subnode record in the ERS\n        bytes32 ersNode = _createChipSubnode(\n            _calculateProjectERSNode(projectInfo),\n            _nameHash,\n            _chipOwner,\n            address(projectInfo.servicesRegistry)\n        );\n\n        // Store chip information\n        chipEnrollments[_chipId] = ChipInfo({\n            nameHash: _nameHash,\n            projectRegistrar: address(projectRegistrar),\n            manufacturerEnrollmentId: _manufacturerValidation.enrollmentId,\n            chipEnrolled: true\n        });\n       \n        // Lockin Period is min of the lockinPeriod specified by the Developer and the max time period specified by governance\n        uint256 lockinPeriod = projectInfo.creationTimestamp + maxLockinPeriod > projectInfo.creationTimestamp + projectInfo.lockinPeriod ?\n            projectInfo.creationTimestamp + projectInfo.lockinPeriod :\n            projectInfo.creationTimestamp + maxLockinPeriod;\n\n        // Set primaryService on ServicesRegistry\n        projectInfo.servicesRegistry.setInitialService(\n            _chipId,\n            projectInfo.serviceId,\n            lockinPeriod\n        );\n\n        if (!projectInfo.chipsAdded) {\n            projectEnrollments[projectRegistrar].chipsAdded = true;\n        }\n\n        emit ChipAdded(\n            _chipId,\n            address(projectRegistrar),\n            _manufacturerValidation.enrollmentId,\n            _chipOwner,\n            projectInfo.serviceId,\n            ersNode,\n            hasDeveloperCustodyProof\n        );\n    }\n\n\n    /**\n     * @dev ONLY Developer REGISTRAR: Remove project enrollment from ChipRegistry. This function is only callable by DeveloperRegistrars. This\n     * function will revert if the project is not enrolled or if the project has already added chips. This function will also remove the project\n     * subnode record in the ERS.\n     *\n     * @param _projectRegistrar          Address of the ProjectRegistrar contract\n     */\n    function removeProjectEnrollment(IProjectRegistrar _projectRegistrar) external {\n        require(developerRegistry.isDeveloperRegistrar(msg.sender), \"Must be Developer Registrar\");\n\n        IDeveloperRegistrar developerRegistrar = IDeveloperRegistrar(msg.sender);\n        ProjectInfo memory projectInfo = projectEnrollments[_projectRegistrar];\n\n        // Check that the project registrar is valid\n        require(address(_projectRegistrar) != address(0), \"Invalid project registrar address\");\n\n        // Verify that the project is enrolled\n        require(projectInfo.creationTimestamp != 0, \"Project not enrolled\");\n\n        // Verify that the project is being removed by the correct developer registrar\n        require(projectInfo.developerRegistrar == developerRegistrar, \"Developer Registrar does not own project\");\n\n        // Verify that the project has not added chips\n        require(!projectInfo.chipsAdded, \"Cannot remove project with chips added\");\n\n        // Get the project's nameHash\n        bytes32 nameHash = projectInfo.nameHash;\n\n        // Remove the chip subnode record in the ERS\n        ers.deleteChipRegistrySubnodeRecord(\n            developerRegistrar.rootNode(),\n            nameHash\n        );\n\n        delete projectEnrollments[_projectRegistrar];\n\n        emit ProjectEnrollmentRemoved(\n            msg.sender,\n            address(_projectRegistrar),\n            nameHash\n        );\n    }\n\n    /**\n     * @notice Set the owner of a chip through its projectRegistrar\n     *\n     * @param _chipId           The chip public key\n     * @param _newOwner         The new owner of the chip\n     */\n    function setChipNodeOwner(\n        address _chipId, \n        address _newOwner\n    ) \n        external \n    {\n        IProjectRegistrar projectRegistrar = IProjectRegistrar(msg.sender);\n        ChipInfo memory chipInfo = chipEnrollments[_chipId];\n\n        require(chipInfo.chipEnrolled, \"Chip not added\");\n        require(chipInfo.projectRegistrar == address(projectRegistrar), \"ProjectRegistrar did not add chip\");\n\n        bytes32 _nameHash = chipInfo.nameHash;\n        bytes32 rootNode = _calculateProjectERSNode(projectEnrollments[projectRegistrar]);\n       \n        bytes32 chipErsNode = keccak256(abi.encodePacked(rootNode, _nameHash));\n        ers.setNodeOwner(chipErsNode, _newOwner);\n    }\n\n    /* ============ External Admin Functions ============ */\n\n    /**\n     * @notice ONLY OWNER: Initialize ChipRegistry contract with ERS and Services Registry addresses. Required due to order of operations\n     * during deploy.\n     *\n     * @param _ers                       Address of the ERS contract\n     * @param _developerRegistry         Address of the DeveloperRegistry contract\n     */\n    function initialize(IERS _ers, IDeveloperRegistry _developerRegistry) external onlyOwner {\n        require(!initialized, \"Contract already initialized\");\n        ers = _ers;\n        developerRegistry = _developerRegistry;\n\n        initialized = true;\n        emit RegistryInitialized(address(_ers), address(_developerRegistry));\n    }\n\n    /**\n     * @notice ONLY OWNER: Update the maximum amount of time a chip can be locked into a service for beyond the project's creation timestamp\n     *\n     * @param _maxLockinPeriod         The new maximum amount of time a chip can be locked into a service for beyond the project's creation timestamp\n     */\n    function updateMaxLockinPeriod(uint256 _maxLockinPeriod) external onlyOwner {\n        require(_maxLockinPeriod > 0, \"Invalid lockin period\");\n\n        maxLockinPeriod = _maxLockinPeriod;\n        emit MaxLockinPeriodUpdated(_maxLockinPeriod);\n    }\n\n    /**\n     * @notice ONLY OWNER: Update the migration signer address\n     *\n     * @param _migrationSigner         The new migration signer address\n     */\n    function updateMigrationSigner(address _migrationSigner) external onlyOwner {\n        migrationSigner = _migrationSigner;\n        emit MigrationSignerUpdated(_migrationSigner);\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     * @notice Return the primary service content.\n     *\n     * @param _chipId           The chip public key\n     * @return                  The content associated with the chip (if chip has been claimed already)\n     */\n    function resolveChip(address _chipId) external view returns (IServicesRegistry.Record[] memory) {\n        require(chipEnrollments[_chipId].chipEnrolled, \"Chip not added\");\n        IServicesRegistry _servicesRegistry = IServicesRegistry(ers.getResolver(node(_chipId)));\n        return _servicesRegistry.getPrimaryServiceContent(_chipId);\n    }\n\n    /**\n     * @notice Get the chip's ERS node (function name follows ENS reverse registar naming conventions)\n     *\n     * @param _chipId           The chip public key\n     * @return                  The ERS node of the chip\n     */\n    function node(address _chipId) public view virtual returns (bytes32) {\n        ProjectInfo memory projectInfo = projectEnrollments[IProjectRegistrar(chipEnrollments[_chipId].projectRegistrar)];\n        ChipInfo memory chipInfo = chipEnrollments[_chipId];\n\n        require(chipInfo.chipEnrolled, \"Chip not added\");\n\n        bytes32 rootNode = _calculateProjectERSNode(projectInfo);\n        bytes32 nameHash = chipEnrollments[_chipId].nameHash;\n\n        return keccak256(abi.encodePacked(rootNode, nameHash));\n    }\n\n    /**\n     * @notice Get the owner of a chip through its projectRegistrar\n     *\n     * @param _chipId           The chip public key\n     * @return                  The owner of the chip\n     */\n    function ownerOf(address _chipId) public view virtual returns (address) {\n        require(chipEnrollments[_chipId].chipEnrolled, \"Chip not added\");\n        IProjectRegistrar projectRegistrar = IProjectRegistrar(chipEnrollments[_chipId].projectRegistrar);\n\n        return projectRegistrar.ownerOf(_chipId);\n    } \n\n        /**\n     * \n     * @param _interfaceId The interface ID to check for\n     */\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(ERC165)\n        returns (bool)\n    {\n        return _interfaceId == type(IChipRegistry).interfaceId ||\n        super.supportsInterface(_interfaceId);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Create a chip subnode record in the ERS; if resolver is not set, set to services registry\n     *\n     * @param _rootNode         The root node of the project\n     * @param _nameHash         The namehash of the chip\n     * @param _owner            The owner of the chip\n     * @param _resolver         The resolver of the chip\n     * @return                  The ERS node of the chip\n     */\n    function _createChipSubnode(\n        bytes32 _rootNode,\n        bytes32 _nameHash,\n        address _owner,\n        address _resolver\n    )\n        internal\n        returns (bytes32)\n    {\n        // Create the chip subnode record in the ERS; if the node already exists, this should revert\n        return ers.createChipRegistrySubnodeRecord(\n            _rootNode, \n            _nameHash, \n            _owner, \n            _resolver\n        );\n    }\n\n    /**\n     * @notice Calculate the project's ERS node\n     *\n     * @param _projectInfo      Struct containing information about the project\n     * @return                  The project's ERS node\n     */\n    function _calculateProjectERSNode(ProjectInfo memory _projectInfo) internal view returns (bytes32) {\n        return ers.getSubnodeHash(_projectInfo.developerRegistrar.rootNode(), _projectInfo.nameHash);\n    }\n\n    /**\n     * @notice Validate the manufacturer certificate for a chip\n     *\n     * @param chipId                The chip public key\n     * @param _manufacturerValidation Struct containing information for chip's inclusion in manufacturer's merkle tree\n     */\n    function _validateManufacturerCertificate(\n        address chipId,\n        IChipRegistry.ManufacturerValidation memory _manufacturerValidation\n    )\n        internal\n        view\n    {\n        bool isEnrolledChip = manufacturerRegistry.isEnrolledChip(\n            _manufacturerValidation.enrollmentId,\n            chipId,\n            _manufacturerValidation.manufacturerCertificate,\n            _manufacturerValidation.payload\n        );\n        bool isValidEnrollment = manufacturerRegistry.isValidEnrollment(_manufacturerValidation.enrollmentId);\n        require(isValidEnrollment, \"Expired manufacturer enrollment\");\n        require(isEnrolledChip, \"Chip not enrolled with ManufacturerRegistry\");\n    }\n\n    /**\n     * \n     * @notice Validate the developer custody proof for a chip; should return true if the developer signed the developer address, \n     * false if the migration signer signed the chipId and should revert if the proof is invalid for either case.\n     * \n     * @param _chipId                 The chip public key\n     * @param _developerRegistrar     The developer's registrar address\n     * @param _custodyProof           The developer's custody proof or migration proof\n     */\n    function _isDeveloperCustodyProofAndValid(\n        address _chipId,\n        address _developerRegistrar,\n        bytes memory _custodyProof\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // For developer custody proofs, the chip signs the developer address. For migration proofs the migration signer signs the chipId\n        bytes32 developerDigest = _hashTypedDataV4(keccak256(abi.encode(\n            keccak256(\"DeveloperCustodyProof(address developerRegistrar)\"),\n            _developerRegistrar\n        )));\n        bytes32 migrationDigest = _hashTypedDataV4(keccak256(abi.encode(\n            keccak256(\"MigrationProof(address chipId,address developerRegistrar)\"),\n            _chipId,\n            _developerRegistrar\n        )));\n\n        // If the developer signed the developer address, return \n        if(_chipId.isValidSignatureNow(developerDigest, _custodyProof))\n            return true;\n        else if(migrationSigner.isValidSignatureNow(migrationDigest, _custodyProof))\n            return false;\n        else\n            revert(\"Invalid custody proof\");\n    }\n}\n"
    },
    "contracts/DeveloperRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nimport { IChipRegistry } from \"./interfaces/IChipRegistry.sol\";\nimport { IERS } from \"./interfaces/IERS.sol\";\nimport { IProjectRegistrar } from \"./interfaces/IProjectRegistrar.sol\";\nimport { IDeveloperRegistry } from \"./interfaces/IDeveloperRegistry.sol\";\nimport { IServicesRegistry } from \"./interfaces/IServicesRegistry.sol\";\n\n/**\n * @title DeveloperRegistrar\n * @author Arx\n *\n * @notice Contract that coordinates adding a new project for a Developer. Each Developer has their own DeveloperRegistrar which is associated\n * with a .ers subnode in the ERS registry ([developer].ers). When adding a new project a subnode under the developer.ers sub-\n * domain is added ([projectName].developer.ers) and the project is enrolled in the ChipRegistry.\n */\ncontract DeveloperRegistrar is Ownable2Step {\n\n    event ProjectAdded(\n        address indexed projectRegistrar,\n        bytes32 projectRootNode\n    );\n        event ProjectRemoved(\n        address indexed projectRegistrar\n    );\n    event RegistrarInitialized(bytes32 rootNode);\n\n    /* ============ State Variables ============ */\n    IChipRegistry public immutable chipRegistry;\n    IERS public immutable ers;\n    IDeveloperRegistry public immutable developerRegistry;\n    IServicesRegistry public immutable servicesRegistry;\n\n    bool public initialized;\n    bytes32 public rootNode;                          // Node off which all Developer project names will branch (ie [projectName].[developerName].ers)\n    address[] public projects;                        // Array of project addresses for enumeration\n    mapping(address => uint256) internal projectIndex; // Maps project addresses to their indices in the array\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructor for DeveloperRegistrar. Sets the owner and ChipRegistry.\n     *\n     * @param _chipRegistry         ChipRegistry contract\n     * @param _ers                  ERS registry\n     * @param _developerRegistry    DeveloperRegistry contract\n     * @param _servicesRegistry     ServicesRegistry contract used by all Projects deployed by this Registrar\n     */\n    constructor(\n        IChipRegistry _chipRegistry,\n        IERS _ers,\n        IDeveloperRegistry _developerRegistry,\n        IServicesRegistry _servicesRegistry\n    )\n        Ownable2Step()\n    {\n        chipRegistry = _chipRegistry;\n        ers = _ers;\n        developerRegistry = _developerRegistry;\n        servicesRegistry = _servicesRegistry;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice ONLY Developer REGISTRY: Initialize DeveloperRegistrar contract with root node. Required due to order of operations\n     * during deploy.\n     *\n     * @param _rootNode         Root node of the Developer\n     */\n    function initialize(address _owner, bytes32 _rootNode) external {\n        require(IDeveloperRegistry(msg.sender) == developerRegistry, \"Caller must be DeveloperRegistry\");\n        require(!initialized, \"Contract already initialized\");\n        \n        _transferOwnership(_owner);\n        rootNode = _rootNode;\n        initialized = true;\n        emit RegistrarInitialized(_rootNode);\n    }\n\n    /**\n     * @notice ONLY OWNER: Add a new project to the Developer. Creates a new subnode in the ENS registry and adds the project\n     * to the ChipRegistry. DeveloperRegistrar's DO NOT have the ability to overwrite their subnodes in ERS, hence if a _nameHash\n     * is already taken, this function will revert. Ownership proof is checked in the ChipRegistry.\n     *\n     * @param _nameHash                     Namehash of the project\n     * @param _projectRegistrar             ProjectRegistrar contract\n     * @param _serviceId                    Service ID of the project\n     * @param _lockinPeriod                 Lockin period of the project\n     */\n\n    function addProject(\n        IProjectRegistrar _projectRegistrar,\n        bytes32 _nameHash,\n        bytes32 _serviceId,\n        uint256 _lockinPeriod\n    )\n        external\n        onlyOwner()\n    {\n        require(address(_projectRegistrar) != address(0), \"Invalid project registrar address\");\n        require(projectIndex[address(_projectRegistrar)] == 0, \"Project already added\");\n\n        bytes32 projectNode = ers.createSubnodeRecord(\n            rootNode,\n            _nameHash,\n            address(_projectRegistrar),\n            address(_projectRegistrar)\n        );\n\n        _projectRegistrar.setRootNode(projectNode);\n\n        projects.push(address(_projectRegistrar));\n        projectIndex[address(_projectRegistrar)] = projects.length - 1;\n\n        chipRegistry.addProjectEnrollment(\n            _projectRegistrar,\n            _nameHash,\n            servicesRegistry,\n            _serviceId,\n            _lockinPeriod\n        );\n\n        emit ProjectAdded(\n            address(_projectRegistrar), \n            projectNode\n        );\n    }\n\n    /**\n     * @notice ONLY OWNER: Remove a project from the Developer. Removes the project from the ChipRegistry.\n     * Only works if no chips have been added.\n     *\n     * @param _projectRegistrar     ProjectRegistrar contract\n     */\n\n    function removeProject(IProjectRegistrar _projectRegistrar) external onlyOwner() {\n        require(address(_projectRegistrar) != address(0), \"Invalid project registrar address\");\n\n        uint index = projectIndex[address(_projectRegistrar)];\n        require(index != 0 || projects[0] == address(_projectRegistrar), \"DeveloperRegistrar: Project not enrolled\");\n\n        uint lastIndex = projects.length - 1;\n        address lastProject = projects[lastIndex];\n\n        projects[index] = lastProject;\n        projectIndex[lastProject] = index;\n\n        projects.pop();\n        delete projectIndex[address(_projectRegistrar)];\n\n        chipRegistry.removeProjectEnrollment(_projectRegistrar);\n\n        emit ProjectRemoved(address(_projectRegistrar));\n    }\n\n    /* ============ View Functions ============ */\n\n    function getProjects() external view returns(address[] memory) {\n        return projects;\n    }\n\n}\n"
    },
    "contracts/DeveloperRegistrarFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport { IDeveloperRegistry } from \"./interfaces/IDeveloperRegistry.sol\";\n\n/**\n * @title DeveloperRegistrarFactory\n * @author Arx\n *\n * @notice Contract used to deploy new DeveloperRegistrars. Callable only by the DeveloperRegistry.\n */\ncontract DeveloperRegistrarFactory {\n\n    /* ============ Events ============ */\n    event DeveloperRegistrarDeployed(address indexed developerRegistrar);\n\n    /* ============ State Variables ============ */\n    address public immutable developerRegistrar;\n    IDeveloperRegistry public immutable developerRegistry;\n\n    /* ============ Constructor ============ */\n    constructor(address _developerRegistrar, IDeveloperRegistry _developerRegistry) {\n        developerRegistrar = _developerRegistrar;\n        developerRegistry = _developerRegistry;\n    }\n\n    /* ============ External Functions ============ */\n    function deployDeveloperRegistrar()\n        external\n        returns(address)\n    {\n        require(IDeveloperRegistry(msg.sender) == developerRegistry, \"Caller must be DeveloperRegistry\");\n\n        address newRegistrar = Clones.clone(developerRegistrar);\n        emit DeveloperRegistrarDeployed(address(newRegistrar));\n        return address(newRegistrar);\n    }\n}\n"
    },
    "contracts/DeveloperRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nimport { AddressArrayUtils } from \"./lib/AddressArrayUtils.sol\";\nimport { IERS } from \"./interfaces/IERS.sol\";\nimport { IManufacturerRegistry } from \"./interfaces/IManufacturerRegistry.sol\";\nimport { IDeveloperRegistrar } from \"./interfaces/IDeveloperRegistrar.sol\";\nimport { IDeveloperRegistrarFactory } from \"./interfaces/IDeveloperRegistrarFactory.sol\";\n\n/**\n * @title DeveloperRegistry\n * @author Arx\n *\n * @notice Contract responsible for tracking and permissioning Developers. Developers are given the ability to create a new DeveloperRegistrar by\n * governance. When creating a new Registrar the Developer is given a new [x].ers name. Governance has the ability to revoke Developer permissions\n * and reassign the ERS name to a new Developer.\n */\ncontract DeveloperRegistry is Ownable2Step {\n\n    using AddressArrayUtils for address[];\n\n    /* ============ Events ============ */\n    event DeveloperRegistrarAdded(address indexed developerRegistrar, address indexed owner, bytes32 rootNode);\n    event DeveloperRegistrarRevoked(address indexed developerRegistrar, bytes32 subnode, bytes32 _nameHash);\n    event DeveloperAllowed(address indexed developerOwner, bytes32 nameHash);\n    event DeveloperDisallowed(address indexed developerOwner);\n    event RegistrarFactoryAdded(address indexed factory);\n    event RegistrarFactoryRemoved(address indexed factory);\n    event RegistryInitialized(address ers);\n\n    /* ============ Modifiers ============ */\n    modifier onlyNameGovernor() {\n        require(msg.sender == nameGovernor, \"Only the Name Governor can call this function\");\n        _;\n    }\n    \n    /* ============ Constants ============ */\n    // Equal to keccak256(abi.encodePacked(uint256(0), keccak256(\"ers\")))\n    bytes32 public constant ROOT_NODE = 0xda53397877d78746657194546b25f20b5c2e580045028a6fa27f07cf94e704ba;\n\n    // TODO: do we add a CHAIN_NODE? Or simply concatenate as `chain-name.ers`?\n    \n    /* ============ State Variables ============ */\n    IERS public ersRegistry;\n    bool public initialized;\n    address public nameGovernor;\n\n    mapping(IDeveloperRegistrarFactory=>bool) public registrarFactories;  // Mapping indicating if address is a registered DeveloperRegistrarFactory\n    mapping(address=>bytes32) public pendingDevelopers;                   // Mapping of Developer owner address to the nameHash they want for their \n                                                                          // DeveloperRegistrar\n    mapping(address=>bool) public isDeveloperRegistrar;                   // Mapping indicating if address is a DeveloperRegistrar\n    address[] internal developerRegistrars;\n\n    /* ============ Constructor ============ */\n    constructor(address _governance) Ownable2Step() {\n        transferOwnership(_governance);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice ONLY OWNER: Initialize ChipRegistry contract with ERS and Services Registry addresses. Required due to order of operations\n     * during deploy.\n     *\n     * @param _ers                       Address of the ERS contract\n     * @param _factories                 Array of DeveloperRegistrarFactory contracts\n     * @param _nameGovernor              Address of the Name Governor which can assign names to Developers\n     */\n    function initialize(\n        IERS _ers,\n        IDeveloperRegistrarFactory[] calldata _factories,\n        address _nameGovernor\n    )\n        external\n        onlyOwner\n    {\n        require(!initialized, \"Contract already initialized\");\n        ersRegistry = _ers;\n        nameGovernor = _nameGovernor;\n\n        for (uint256 i = 0; i < _factories.length; ++i) {\n            _addRegistrarFactory(_factories[i]);\n        }\n\n        initialized = true;\n        emit RegistryInitialized(address(_ers));\n    }\n\n    /**\n     * @notice Create a new DeveloperRegistrar for a Developer. In order to call, the calling address must be approved by governance. Once called\n     * the Developer must be added again if they want to launch a new DeveloperRegistrar. This function assigns the DeveloperRegistrar it's own\n     * .ers name. The passed nameHash must be different than any other DeveloperRegistrar's nameHash.\n     *\n     * @param _factory              Address of the DeveloperRegistrarFactory to use for deploying the DeveloperRegistrar\n     */\n    function createNewDeveloperRegistrar(IDeveloperRegistrarFactory _factory) external returns(address) {\n        require(registrarFactories[_factory], \"Factory must be approved DeveloperRegistrarFactory\");\n        require(pendingDevelopers[msg.sender] != bytes32(0), \"Caller must be approved Developer address\");\n\n        // Save Developers nameHash in memory and then delete from storage\n        bytes32 nameHash = pendingDevelopers[msg.sender];\n        delete pendingDevelopers[msg.sender];\n\n        // Passing the owner of the new Registrar to the Factory. Caller is set as owner. This can be transferred to a multisig later.\n        address newRegistrar = IDeveloperRegistrarFactory(_factory).deployDeveloperRegistrar();\n        bytes32 registrarRootNode = ersRegistry.createSubnodeRecord(ROOT_NODE, nameHash, newRegistrar, newRegistrar);\n\n        // Registrar is a trusted contract that we initialize with a root node\n        IDeveloperRegistrar(newRegistrar).initialize(msg.sender, registrarRootNode);\n\n        isDeveloperRegistrar[newRegistrar] = true;\n        developerRegistrars.push(newRegistrar);\n\n        emit DeveloperRegistrarAdded(newRegistrar, msg.sender, registrarRootNode);\n        return newRegistrar;\n    }\n\n    /**\n     * @notice ONLY OWNER: Revoke permissions from a DeveloperRegistrar. This resets the owner and resolver to the zero address in the ERSRegistry\n     * and removes tracking of the DeveloperRegistrar within the DeveloperRegistry (delete from developerRegistrars array and isDeveloperRegistrar\n     * mapping). \n     *\n     * @param _developerRegistrar   Address of the DeveloperRegistrar that is being revoked\n     * @param _nameHash             Bytes32 hash of the ERS name the Developer wants for their Registrar\n     */\n    function revokeDeveloperRegistrar(address _developerRegistrar, bytes32 _nameHash) external onlyOwner {\n        require(isDeveloperRegistrar[_developerRegistrar], \"Not a DeveloperRegistrar\");\n\n        // Validate that _nameHash is the nameHash of the DeveloperRegistrar. We can do this check because we know the DeveloperRegistrar's root node\n        // cannot be updated since it a trusted contract.\n        bytes32 subnodeHash = ersRegistry.getSubnodeHash(ROOT_NODE, _nameHash);\n        bytes32 registrarRootNode = IDeveloperRegistrar(_developerRegistrar).rootNode();\n        require(subnodeHash == registrarRootNode, \"Passed subnode does not match Registrar's root node\");\n\n        ersRegistry.deleteSubnodeRecord(ROOT_NODE, _nameHash);\n\n        delete isDeveloperRegistrar[_developerRegistrar];\n        developerRegistrars.removeStorage(_developerRegistrar);\n        \n        emit DeveloperRegistrarRevoked(_developerRegistrar, subnodeHash, _nameHash);\n    }\n\n    /**\n     * @notice ONLY OWNER: Add a new address that can create a new DeveloperRegistrar. Since ERS names have value we want them to commit to a name\n     * up front. The passed nameHash must be different than any other DeveloperRegistrar's nameHash and not bytes32(0).\n     *\n     * @param _developerOwner       Address that has the ability to create a new DeveloperRegistrar with the below nameHash\n     * @param _nameHash             Bytes32 hash of the ERS name the Developer wants for their Registrar\n     */\n    function addAllowedDeveloper(address _developerOwner, bytes32 _nameHash) external onlyNameGovernor {\n        require(pendingDevelopers[_developerOwner] == bytes32(0), \"Developer already allowed\");\n        // can't allow zero bytes since it's the default value for pendingDevelopers. Will not allow someone to deploy a Registrar with zero\n        // bytes name.\n        require(_nameHash != bytes32(0), \"Invalid name hash\");\n        require(_developerOwner != address(0), \"Invalid Developer owner address\");\n        require(ersRegistry.getSubnodeOwner(ROOT_NODE, _nameHash) == address(0), \"Name already taken\");\n\n        pendingDevelopers[_developerOwner] = _nameHash;\n        emit DeveloperAllowed(_developerOwner, _nameHash);\n    }\n\n    /**\n     * @notice ONLY OWNER: Remove an address from creating a new DeveloperRegistrar. \n     *\n     * @param _developerOwner       Address that has the ability to create a new DeveloperRegistrar with the below nameHash\n     */\n    function removeAllowedDeveloper(address _developerOwner) external onlyNameGovernor {\n        require(pendingDevelopers[_developerOwner]!= bytes32(0), \"Developer not allowed\");\n\n        delete pendingDevelopers[_developerOwner];\n        emit DeveloperDisallowed(_developerOwner);\n    }\n\n    /**\n     * @notice ONLY OWNER: Add a new DeveloperRegistrarFactory that can be used for creating new DeveloperRegistrars; examples\n     * might include registrars with interspersed nodes (e.g. project.group.developer.ers) \n     *\n     * @param _factory             Address of DeveloperRegistrarFactory to add\n     */\n    function addRegistrarFactory(IDeveloperRegistrarFactory _factory) external onlyOwner {\n        _addRegistrarFactory(_factory);\n    }\n\n    /**\n     * @notice ONLY OWNER: Remove a DeveloperRegistrarFactory so that it can't be used for creating new DeveloperRegistrars.\n     *\n     * @param _factory             Address of DeveloperRegistrarFactory to add\n     */\n    function removeRegistrarFactory(IDeveloperRegistrarFactory _factory) external onlyOwner {\n        require(registrarFactories[_factory], \"Factory not added\");\n\n        delete registrarFactories[_factory];\n        emit RegistrarFactoryRemoved(address(_factory));\n    }\n\n    /* ============ View Functions ============ */\n    \n    function getDeveloperRegistrars() external view returns(address[] memory) {\n        return developerRegistrars;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _addRegistrarFactory(IDeveloperRegistrarFactory _factory) internal {\n        require(!registrarFactories[_factory], \"Factory already added\");\n        require(address(_factory) != address(0), \"Invalid factory address\");\n\n        registrarFactories[_factory] = true;\n        emit RegistrarFactoryAdded(address(_factory));\n    }\n}\n"
    },
    "contracts/ERSRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { IChipRegistry } from \"./interfaces/IChipRegistry.sol\";\nimport { IDeveloperRegistry } from \"./interfaces/IDeveloperRegistry.sol\";\n\n/**\n * @title ERSRegistry\n * @author Arx\n *\n * @notice Fork of ENSRegistry with adapted data structures and accessiblity logic in order to conform to needs of ERS. Node\n * owners can create any subnode. A node tracks the owner of the node and the address the node resolves to. Within the\n * context of ERS a resolver represents either a smart contract OR a chip. The owner has the ability to create any subnodes\n * of its choosing, however only the DeveloperRegistry is able to change both the owner and the resolver for a given node once\n * created. The ChipRegistry is able to change the owner of a node (signifying a transfer of a chip) but is not able to \n * change the resolver. These permissions are put in place in order to maintain a track record of authenticity for chips\n * while allowing the DeveloperRegistry to re-assign sub-domains to new DeveloperRegistrars. Note that if a DeveloperRegistry's\n * subnode is reassigned to a new DeveloperRegistrar the new DeveloperRegistrar CANNOT overwrite the nodes created by the\n * previous node owner.\n */\ncontract ERSRegistry {\n\n    /* ============ Events ============ */\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed subnode, bytes32 indexed nameHash, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    /* ============ Structs ============ */\n    struct Record {\n        address owner;\n        address resolver;\n    }\n\n    /* ============ Modifiers ============ */\n    // Permits modifications only by the owner of the specified node.\n    modifier authorised(bytes32 _node) {\n        address owner = records[_node].owner;\n        require(owner == msg.sender, \"Must be node owner\");\n        _;\n    }\n\n    /* ============ State Variables ============ */\n    IChipRegistry public immutable chipRegistry;\n    IDeveloperRegistry public immutable developerRegistry;\n    \n    mapping(bytes32 => Record) public records;\n    \n    /* ============ Constructor ============ */\n\n    /**\n     * @dev Constructs a new ERS registry.\n     */\n    constructor(IChipRegistry _chipRegistry, IDeveloperRegistry _developerRegistry) {\n        chipRegistry = _chipRegistry;\n        developerRegistry = _developerRegistry;\n        records[0x0].owner = msg.sender;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @dev ONLY CHIP REGISTRY: Sets the record on behalf of a new chip or project subnode. Note that ChipRegistry is not the node owner.\n     *\n     * @param _node     The parent node.\n     * @param _nameHash The hash of the nameHash specifying the subnode.\n     * @param _owner    The address of the new owner.\n     * @param _resolver The address that the new nameHash resolves to.\n     * @return The newly created subnode hash\n     */\n    function createChipRegistrySubnodeRecord(\n        bytes32 _node,\n        bytes32 _nameHash,\n        address _owner,\n        address _resolver\n    )\n        external\n        virtual\n        returns(bytes32)\n    {\n        require(msg.sender == address(chipRegistry), \"Caller must be ChipRegistry\");\n        bytes32 subnode = _calculateSubnode(_node, _nameHash);\n        require(_owner != address(0), \"New owner cannot be null address\");\n        require(!recordExists(subnode), \"Subnode already exists\");\n\n        _setOwner(subnode, _owner);\n        _setResolver(subnode, _resolver);\n\n        emit NewOwner(_node, subnode, _nameHash, _owner);\n        return subnode;\n    }\n\n     /**\n     * @dev ONLY CHIP REGISTRY: Delete the record for a project subnode. Note that ChipRegistry is not the node owner.\n     *\n     * @param _node     The parent node.\n     * @param _nameHash The hash of the nameHash specifying the subnode.\n     */\n    function deleteChipRegistrySubnodeRecord(\n        bytes32 _node,\n        bytes32 _nameHash\n    )\n        external\n        virtual\n    {\n        // Note: we're expecting ChipRegistry to validate that the DeveloperRegistrar is the owner of the Project who created the node.\n        require(msg.sender == address(chipRegistry), \"Caller must be ChipRegistry\");\n        \n        bytes32 subnode = _calculateSubnode(_node, _nameHash);\n        require(recordExists(subnode), \"Subnode does not exist\");\n\n        _setOwner(subnode, address(0));\n        _setResolver(subnode, address(0));\n\n        emit NewOwner(_node, subnode, _nameHash, address(0));\n    }\n\n    /**\n     * @dev ONLY DEPLOYER, DEVELOPER REGISTRY or DEVELOPER REGISTRAR: Sets the record for a new subnode. May only be called by owner of node (checked\n     * in _setSubnodeOwner).\n     *\n     * @param _node     The parent node.\n     * @param _nameHash The hash of the nameHash specifying the subnode.\n     * @param _owner    The address of the new owner.\n     * @param _resolver The address that the new nameHash resolves to.\n     * @return The newly created subnode hash\n     */\n    function createSubnodeRecord(\n        bytes32 _node,\n        bytes32 _nameHash,\n        address _owner,\n        address _resolver\n    )\n        external\n        virtual\n        authorised(_node)\n        returns(bytes32)\n    {\n        address deployerCaller = records[0x0].owner;\n\n        // Check to see if caller is the ERS deployer, DeveloperRegistry or a DeveloperRegistrar\n        require(\n            msg.sender == deployerCaller || msg.sender == address(developerRegistry) || developerRegistry.isDeveloperRegistrar(msg.sender),\n            \"Caller must be Deployer or DeveloperRegistry\"\n        );\n        \n        bytes32 subnode = _calculateSubnode(_node, _nameHash);\n        require(_owner != address(0), \"New owner cannot be null address\");\n        require(!recordExists(subnode), \"Subnode already exists\");\n\n        _setOwner(subnode, _owner);\n        _setResolver(subnode, _resolver);\n\n        emit NewOwner(_node, subnode, _nameHash, _owner);\n        return subnode;\n    }\n\n    /**\n     * @dev ONLY Developer REGISTRY: Deletes the record for an already created subnode. Developer Registry must be the owner of the node so as to not\n     * accidentally delete a non DeveloperRegistrar subnode.\n     *\n     * @param _node     The parent node.\n     * @param _nameHash The hash of the nameHash specifying the subnode.\n     */\n    function deleteSubnodeRecord(\n        bytes32 _node,\n        bytes32 _nameHash\n    )\n        external\n        virtual\n        authorised(_node)\n    {\n        require(msg.sender == address(developerRegistry), \"Caller must be DeveloperRegistry\");\n\n        bytes32 subnode = _calculateSubnode(_node, _nameHash);\n        require(recordExists(subnode), \"Subnode does not exist\");\n\n        _setOwner(subnode, address(0));\n        _setResolver(subnode, address(0));\n\n        emit NewOwner(_node, subnode, _nameHash, address(0));\n    }\n\n    /**\n     * @dev ONLY CHIP REGISTRY: Transfers ownership of a node to a new address. Owner cannot directly call (unless root node),\n     * ChipRegistry must manage ownership changes for chips in order to keep state consistent between ChipRegistry and ERS.\n     *\n     * @param _node     The node to transfer ownership of.\n     * @param _newOwner The address of the new owner.\n     */\n    function setNodeOwner(\n        bytes32 _node,\n        address _newOwner\n    )\n        external\n        virtual\n    {\n        // if node isn't 0x0 then ChipRegistry must be caller, if it is then owner must be caller\n        address requiredCaller = _node == 0x0 ? records[_node].owner : address(chipRegistry);\n        require(msg.sender == requiredCaller, \"Caller must be ChipRegistry or owner of node\");\n        require(_newOwner != address(0), \"New owner cannot be null address\");\n        require(recordExists(_node), \"Node does not exist\");\n\n        _setOwner(_node, _newOwner);\n        emit Transfer(_node, _newOwner);\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     * @dev Returns the address that owns the specified node.\n     *\n     * @param _node     The specified node.\n     * @return address of the owner.\n     */\n    function getOwner(bytes32 _node) public view virtual returns (address) {\n        return records[_node].owner;\n    }\n\n    /**\n     * @dev Returns the address that owns the specified subnode.\n     *\n     * @param _node         The specified node.\n     * @param _nameHash     The specified nameHash.\n     * @return address of the owner.\n     */\n    function getSubnodeOwner(bytes32 _node, bytes32 _nameHash) public view virtual returns (address) {\n        bytes32 subnode = _calculateSubnode(_node, _nameHash);\n        return getOwner(subnode);\n    }\n\n    /**\n     * @dev Returns the address of the resolver for the specified node.\n     *\n     * @param _node     The specified node.\n     * @return address of the resolver.\n     */\n    function getResolver(bytes32 _node) external view virtual returns (address) {\n        return records[_node].resolver;\n    }\n\n    /**\n     * @dev Returns whether a record has been written to the registry for that node.\n     *\n     * @param _node The specified node.\n     * @return Bool if record exists\n     */\n    function recordExists(bytes32 _node) public view virtual returns (bool) {\n        return records[_node].owner != address(0);\n    }\n\n    /**\n     * @dev Returns the subnode hash of node + nameHash. This is the keccak256 hash of `node` + `nameHash`.\n     *\n     * @param _node     The specified node.\n     * @param _nameHash The specified nameHash.\n     */\n    function getSubnodeHash(bytes32 _node, bytes32 _nameHash) external pure returns (bytes32) {\n        return _calculateSubnode(_node, _nameHash);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _calculateSubnode(bytes32 _node, bytes32 _nameHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_node, _nameHash));\n    }\n\n    function _setOwner(bytes32 node, address owner) internal virtual {\n        records[node].owner = owner;\n    }\n\n    function _setResolver(bytes32 _node, address _resolver) internal virtual {\n        records[_node].resolver = _resolver;\n        emit NewResolver(_node, _resolver);\n    }\n}\n"
    },
    "contracts/governance/DeveloperNameGovernor.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport { IDeveloperRegistry } from \"../interfaces/IDeveloperRegistry.sol\";\n\n/**\n * @title DeveloperNameGovernor\n * @notice Contract that coordinates adding a new project for a Developer. Each Developer has their own DeveloperRegistrar which is associated\n * with a .ers subnode in the ERS registry ([developer].ers). In order for a valid name claim the caller must submit a transaction with a valid\n * signature signed by the coordinator of this contract over hash(developerAddress, developerName).\n */\n\ncontract DeveloperNameGovernor is Ownable2Step, EIP712 {\n\n    using ECDSA for bytes;\n    using SignatureChecker for address;\n\n    /* ============ Events ============ */\n    event NameCoordinatorUpdated(address newNameCoordinator);\n\n    /* ============ Constants ============ */\n    // Match signature version to project version.\n    string public constant EIP712_SIGNATURE_DOMAIN = \"ERS\";\n    string public constant EIP712_SIGNATURE_VERSION = \"2.0.0\";\n\n    /* ============ State Variables ============ */\n    IDeveloperRegistry public immutable developerRegistry;\n    address public nameCoordinator;\n\n    /* ============ Constructor ============ */\n    /**\n     * @notice Constructor for DeveloperNameGovernor. Sets the owner and DeveloperRegistry.\n     *\n     * @param _developerRegistry    DeveloperRegistry contract\n     * @param _nameCoordinator      Address of the signer of name claims\n     */\n    constructor(IDeveloperRegistry _developerRegistry, address _nameCoordinator)\n        Ownable2Step()\n        EIP712(EIP712_SIGNATURE_DOMAIN, EIP712_SIGNATURE_VERSION) \n    {\n        developerRegistry = _developerRegistry;\n        nameCoordinator = _nameCoordinator;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice Claim a name for a developer. The caller must submit a transaction with a valid signature signed by the name coordinator. The\n     * name coordinator performs checks for name validity and availability.\n     *\n     * @param _developerName        ERS name of the developer\n     * @param _nameApprovalProof    Signature of the name coordinator over hash(msg.sender, developerName)\n     */\n    function claimName(\n        bytes32 _developerName,\n        uint256 _proofTimestamp,\n        bytes memory _nameApprovalProof\n    ) public {\n        address sender = msg.sender;\n\n        // Name Approval Proofs are generated by a trusted signer; an expiration prevents replays after a nameClaim is removed.\n        require(block.timestamp <= _proofTimestamp + 24 hours, \"Expired signature\");\n\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n            keccak256(\"NameApprovalProof(address developerOwner,bytes32 developerName,uint256 proofTimestamp)\"),\n            sender,\n            _developerName,\n            _proofTimestamp\n        )));\n        \n        require(nameCoordinator.isValidSignatureNow(digest, _nameApprovalProof), \"Invalid signature\");\n\n        developerRegistry.addAllowedDeveloper(sender, _developerName);\n    }\n\n    /**\n     * @notice ONLY OWNER: Remove a name claim for a developer.\n     *\n     * @param _developerOwner       Address of the developer owner\n     */\n    function removeNameClaim(address _developerOwner) public onlyOwner {\n        developerRegistry.removeAllowedDeveloper(_developerOwner);\n    }\n\n    /**\n     * @notice ONLY OWNER: Update the name coordinator.\n     *\n     * @param _newNameCoordinator       Address of the new name coordinator\n     */\n    function updateNameCoordinator(address _newNameCoordinator) public onlyOwner {\n        require(_newNameCoordinator != address(0), \"Address cannot be zero address\");\n        nameCoordinator = _newNameCoordinator;\n\n        emit NameCoordinatorUpdated(_newNameCoordinator);\n    }\n}\n"
    },
    "contracts/interfaces/IChipRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { IProjectRegistrar } from \"./IProjectRegistrar.sol\";\nimport { IServicesRegistry } from \"./IServicesRegistry.sol\";\n\ninterface IChipRegistry {\n    function servicesRegistry() external view returns (address);\n\n    struct ManufacturerValidation\n     {\n        bytes32 enrollmentId;\n        bytes manufacturerCertificate;\n        bytes payload;\n    }\n\n    function addProjectEnrollment(\n        IProjectRegistrar _projectRegistrar,\n        bytes32 _nameHash,\n        IServicesRegistry _servicesRegistry,\n        bytes32 _serviceId,\n        uint256 _lockinPeriod\n    )\n        external;\n\n    function addChip(\n        address _chipId,\n        address _owner,\n        bytes32 _nameHash,\n        ManufacturerValidation calldata _manufacturerValidation,\n        bytes calldata _custodyProof\n    )\n        external;\n\n    function removeProjectEnrollment(\n        IProjectRegistrar _projectRegistrar\n    )\n        external;\n\n    function setChipNodeOwner(\n        address _chipId,\n        address _newOwner\n    )\n        external;\n\n    function resolveChip(\n        bytes32 _nameHash\n    )\n        external view returns (address);\n\n    function node(\n        address _chipId\n    )\n        external view returns (bytes32);\n\n    function ownerOf(\n        address _chipId\n    )\n        external view returns (address);\n\n}\n"
    },
    "contracts/interfaces/IDeveloperRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { IProjectRegistrar } from \"./IProjectRegistrar.sol\";\n\ninterface IDeveloperRegistrar {\n    function initialize(address _owner, bytes32 _rootNode) external;\n    function rootNode() external view returns (bytes32);\n    function owner() external view returns (address);\n\n    function addProject(\n        IProjectRegistrar _projectRegistrar,\n        bytes32 _nameHash,\n        bytes32 _serviceId,\n        uint256 _lockinPeriod\n    )\n        external;\n\n    function removeProject(\n        IProjectRegistrar _projectRegistrar\n    )\n        external;\n\n    function getProjects() external view returns (address[] memory);\n     \n}\n"
    },
    "contracts/interfaces/IDeveloperRegistrarFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ninterface IDeveloperRegistrarFactory {\n    function deployDeveloperRegistrar() external returns(address);\n}\n"
    },
    "contracts/interfaces/IDeveloperRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ninterface IDeveloperRegistry {\n    function addAllowedDeveloper(address _developerOwner, bytes32 _nameHash) external;\n    function removeAllowedDeveloper(address _developerOwner) external;\n    function isDeveloperRegistrar(address _registrar) external view returns(bool);\n}\n"
    },
    "contracts/interfaces/IEnrollmentAuthModel.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ninterface IEnrollmentAuthModel {\n    function verifyManufacturerCertificate(\n        address chipId,\n        address manufacturerCertSigner,\n        bytes calldata manufacturerCertificate,\n        bytes calldata payload\n    ) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERS.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\n\ninterface IERS {\n\n    function createChipRegistrySubnodeRecord(\n        bytes32 _node,\n        bytes32 _nameHash,\n        address _owner,\n        address _resolver\n    ) external returns(bytes32);\n\n    function createSubnodeRecord(\n        bytes32 _node,\n        bytes32 _nameHash,\n        address _owner,\n        address _resolver\n    ) external returns(bytes32);\n\n    function deleteChipRegistrySubnodeRecord(\n        bytes32 _node,\n        bytes32 _nameHash\n    ) external;\n\n    function deleteSubnodeRecord(\n        bytes32 _node,\n        bytes32 _nameHash\n    ) external;\n\n    function setNodeOwner(\n        bytes32 _node,\n        address _owner\n    ) external;\n\n    function getSubnodeHash(\n        bytes32 _node,\n        bytes32 _nameHash\n    )\n        external\n        pure\n        returns (bytes32);\n\n    function getOwner(\n        bytes32 _node\n    )\n        external\n        view\n        returns (address);\n\n    function getSubnodeOwner(\n        bytes32 _node,\n        bytes32 _nameHash\n    )\n        external\n        view\n        returns (address);\n\n    function getResolver(\n        bytes32 _node\n    )\n        external\n        view\n        returns (address);\n\n    function recordExists(\n        bytes32 _node\n    )\n        external\n        view\n        returns (bool);\n}\n"
    },
    "contracts/interfaces/IManufacturerRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ninterface IManufacturerRegistry {\n    function isEnrolledChip(\n        bytes32 _enrollmentId,\n        address _chipId,\n        bytes calldata _manufacturerCertificate,\n        bytes calldata _payload     \n    )\n        external\n        view\n        returns (bool);\n\n    function isValidEnrollment (\n        bytes32 _enrollmentId\n    )\n        external\n        view\n        returns (bool);\n\n    function getEnrollmentBootloaderApp(bytes32 _enrollmentId) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IProjectRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ninterface IProjectRegistrar {\n    function rootNode() external view returns (bytes32);\n    \n    function setRootNode(\n        bytes32 _rootNode\n    )\n        external;\n\n    function ownerOf(address _chipId) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IServicesRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ninterface IServicesRegistry {\n    struct Record {\n        bytes32 recordType;\n        bytes content;\n    }\n\n    struct Service {\n        bytes32 serviceId;\n        Record[] records;\n    }\n\n    struct ExpandedChipServices {\n        Service primaryService;\n        uint256 serviceTimelock;\n        Service[] secondaryServices;\n    }\n\n    function setInitialService(address _chipId, bytes32 _serviceId, uint256 _timelock) external;\n    function getPrimaryServiceContentByRecordtype(address _chipId, bytes32 _datatype) external view returns (bytes memory);\n    function getPrimaryServiceContent(address _chipId) external view returns (Record[] memory);\n    function getServiceContent(address _chipId, bytes32 _serviceId) external view returns (Record[] memory);\n    function isService(bytes32 _serviceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ITransferPolicy.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\ninterface ITransferPolicy {\n    function authorizeTransfer(\n        address _chipId,\n        address _sender,\n        address _chipOwner,\n        bytes calldata _payload,\n        bytes calldata _signature\n    ) external;\n}\n"
    },
    "contracts/lib/AddressArrayUtils.sol": {
      "content": "/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: MIT\n*/\n\npragma solidity ^0.8.24;\n\n/**\n * @title AddressArrayUtils\n * @author Set Protocol\n *\n * Utility functions to handle Address Arrays\n *\n * CHANGELOG:\n * - 4/21/21: Added validatePairsWithArray methods\n */\nlibrary AddressArrayUtils {\n\n    uint256 constant internal MAX_INT = 2**256 - 1;\n\n    /**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (MAX_INT, false);\n    }\n\n    /**\n    * Returns true if the value is present in the list. Uses indexOf internally.\n    * @param A The input array to search\n    * @param a The value to find\n    * @return Returns isIn for the first occurrence starting from index 0\n    */\n    function contains(address[] memory A, address a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n    * Returns true if there are 2 elements that are the same in an array\n    * @param A The input array to search\n    * @return Returns boolean for the first occurrence of a duplicate\n    */\n    function hasDuplicate(address[] memory A) internal pure returns(bool) {\n        require(A.length > 0, \"A is empty\");\n\n        for (uint256 i = 0; i < A.length - 1; i++) {\n            address current = A[i];\n            for (uint256 j = i + 1; j < A.length; j++) {\n                if (current == A[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The address to remove\n     * @return Returns the array with the object removed.\n     */\n    function remove(address[] memory A, address a)\n        internal\n        pure\n        returns (address[] memory)\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"Address not in array.\");\n        } else {\n            (address[] memory _A,) = pop(A, index);\n            return _A;\n        }\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The address to remove\n     */\n    function removeStorage(address[] storage A, address a)\n        internal\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"Address not in array.\");\n        } else {\n            uint256 lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\n            if (index != lastIndex) { A[index] = A[lastIndex]; }\n            A.pop();\n        }\n    }\n\n    /**\n    * Removes specified index from array\n    * @param A The input array to search\n    * @param index The index to remove\n    * @return Returns the new array and the removed entry\n    */\n    function pop(address[] memory A, uint256 index)\n        internal\n        pure\n        returns (address[] memory, address)\n    {\n        uint256 length = A.length;\n        require(index < A.length, \"Index must be < A length\");\n        address[] memory newAddresses = new address[](length - 1);\n        for (uint256 i = 0; i < index; i++) {\n            newAddresses[i] = A[i];\n        }\n        for (uint256 j = index + 1; j < length; j++) {\n            newAddresses[j - 1] = A[j];\n        }\n        return (newAddresses, A[index]);\n    }\n}\n"
    },
    "contracts/lib/Bytes32ArrayUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\n/**\n * @title Bytes32ArrayUtils\n * @author Arx Research\n *\n * Fork of Set Protocol's AddressArrayUtils library adapted for usage with bytes32 arrays.\n */\nlibrary Bytes32ArrayUtils {\n\n    uint256 constant internal MAX_INT = 2**256 - 1;\n\n    /**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(bytes32[] memory A, bytes32 a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (MAX_INT, false);\n    }\n\n    /**\n    * Returns true if the value is present in the list. Uses indexOf internally.\n    * @param A The input array to search\n    * @param a The value to find\n    * @return Returns isIn for the first occurrence starting from index 0\n    */\n    function contains(bytes32[] memory A, bytes32 a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n    * Returns true if there are 2 elements that are the same in an array\n    * @param A The input array to search\n    * @return Returns boolean for the first occurrence of a duplicate\n    */\n    function hasDuplicate(bytes32[] memory A) internal pure returns(bool) {\n        require(A.length > 0, \"A is empty\");\n\n        for (uint256 i = 0; i < A.length - 1; i++) {\n            bytes32 current = A[i];\n            for (uint256 j = i + 1; j < A.length; j++) {\n                if (current == A[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The bytes32 to remove\n     * @return Returns the array with the object removed.\n     */\n    function remove(bytes32[] memory A, bytes32 a)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"bytes32 not in array.\");\n        } else {\n            (bytes32[] memory _A,) = pop(A, index);\n            return _A;\n        }\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The bytes32 to remove\n     */\n    function removeStorage(bytes32[] storage A, bytes32 a)\n        internal\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"bytes32 not in array.\");\n        } else {\n            uint256 lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\n            if (index != lastIndex) { A[index] = A[lastIndex]; }\n            A.pop();\n        }\n    }\n\n    /**\n    * Removes specified index from array\n    * @param A The input array to search\n    * @param index The index to remove\n    * @return Returns the new array and the removed entry\n    */\n    function pop(bytes32[] memory A, uint256 index)\n        internal\n        pure\n        returns (bytes32[] memory, bytes32)\n    {\n        uint256 length = A.length;\n        require(index < A.length, \"Index must be < A length\");\n        bytes32[] memory newBytes = new bytes32[](length - 1);\n        for (uint256 i = 0; i < index; i++) {\n            newBytes[i] = A[i];\n        }\n        for (uint256 j = index + 1; j < length; j++) {\n            newBytes[j - 1] = A[j];\n        }\n        return (newBytes, A[index]);\n    }\n}\n"
    },
    "contracts/lib/ChipValidations.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\nlibrary ChipValidations {\n    using SignatureChecker for address;\n    using ECDSA for bytes;\n\n    function validateSignatureAndExpiration(\n        address _chipId,\n        uint256 _commitBlock,\n        uint256 _maxBlockWindow,\n        bytes memory _payload,\n        bytes memory _signature\n    )\n        internal\n        view\n    {\n        require(_chipId.isValidSignatureNow(_payload.toEthSignedMessageHash(), _signature), \"Invalid signature\");\n\n        // Check that the signature was generated within the maxBlockWindow\n        require(block.number <= _commitBlock + _maxBlockWindow, \"Signature expired\");\n    }\n}\n"
    },
    "contracts/lib/StringArrayUtils.sol": {
      "content": "/*\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache-2.0\n*/\n\npragma solidity ^0.8.24;\n\n/**\n * @title StringArrayUtils\n * @author Set Protocol\n *\n * Utility functions to handle String Arrays\n */\nlibrary StringArrayUtils {\n\n    uint256 constant internal MAX_INT = 2**256 - 1;\n\n    /**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input string to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(string[] memory A, string memory a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (keccak256(bytes(A[i])) == keccak256(bytes(a))) {\n                return (i, true);\n            }\n        }\n        return (MAX_INT, false);\n    }\n\n    /**\n    * Returns true if the value is present in the list. Uses indexOf internally.\n    * @param A The input array to search\n    * @param a The value to find\n    * @return Returns isIn for the first occurrence starting from index 0\n    */\n    function contains(string[] memory A, string memory a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The string to remove\n     */\n    function removeStorage(string[] storage A, string memory a)\n        internal\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"String not in array.\");\n        } else {\n            uint256 lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\n            if (index != lastIndex) { A[index] = A[lastIndex]; }\n            A.pop();\n        }\n    }\n}\n"
    },
    "contracts/ManufacturerRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { IEnrollmentAuthModel } from \"./interfaces/IEnrollmentAuthModel.sol\";\n\n/**\n * @title ManufacturerRegistry\n * @author Arx\n *\n * @notice Registry for tracking and maintaining relevant info for Manufacturers. In order to make chips valid for the\n * protocol, manufacturers must register their chips in enrollments. Each enrollment will be assigned an id, which\n * must be referenced when adding chips to the registry. Enrollments have a merkle root of all chipIds (addresses)\n * that are valid for the enrollment. Manufacturer's can be found in three states:\n * 1. Unregistered: manufacturers[_manufacturerId].registered = false. This is the default state for all manufacturers.\n * 2. Registered: manufacturers[_manufacturerId].registered = true && manufacturers[_manufacturerId].owner != address(0).\n * 3. Read-only: manufacturers[_manufacturerId].registered = true && manufacturers[_manufacturerId].owner == address(0).\n *    Once a manufacturerId has been put in this state it CANNOT leave it.\n */\ncontract ManufacturerRegistry is Ownable2Step {\n\n    /* ============ Events ============ */\n    event ManufacturerAdded(                // Called in addManufacturer\n        bytes32 indexed manufacturerId,\n        address owner\n    );\n    event ManufacturerRemoved(              // Called in removeManufacturer\n        bytes32 indexed manufacturerId\n    );\n\n    event EnrollmentAdded(                        // Called in addChipEnrollment\n        bytes32 indexed manufacturerId,           // Manufacturer identifier\n        bytes32 indexed enrollmentId,             // Enrollment identifier\n        address manufacturerCertSigner,           // Address of certificate signer for this enrollment\n        address authModel,                        // Address of contract that implements example signature validation for a chip\n        IEnrollmentAuthModel enrollmentAuthModel, // Address of contract that implements example signature validation for manufacturerCertificates\n        string chipValidationDataUri,             // Optional: URI pointing to location of off-chain manufacturer enrollment validation data\n        string bootloaderApp,                     // Optional: Bootloader app for this enrollment\n        string chipModel                          // Chip model for this enrollment\n    );\n\n    event ManufacturerOwnerUpdated(         // Called in updateManufacturerOwner\n        bytes32 indexed manufacturerId,\n        address newOwner\n    );\n\n    /* ============ Structs ============ */\n\n    struct EnrollmentInfo {\n        uint256 manufacturerId;\n        address manufacturerCertSigner;\n        address authModel;                          // Address with implementation for validating chip signatures\n        IEnrollmentAuthModel enrollmentAuthModel;   // Address with implementation for validating manufacturerCertificates in an enrollment\n        bool active;                                // If enrollment can be used to validate chips        \n        string chipValidationDataUri;               // Optional: URI pointing to location of off-chain manufacturer enrollment validation data\n        string bootloaderApp;                       // Optional: Bootloader app for this enrollment\n        string chipModel;                           // Description of chip\n    }\n\n    struct ManufacturerInfo {\n        address owner;                      // Address that has ability to add enrollments for this manufacturer; turning off access is done by\n                                            // setting owner to 0 address\n        bool registered;                    // If manufacturer is registered, manufacturers cannot be unregistered in order to keep history,\n                                            // burn access by setting owner to 0 address\n        bytes32[] enrollments;\n        uint256 nonce;                      // Nonce for manufacturer, incremented after each new enrollment by manufacturer\n    }\n\n    /* ============ Modifiers ============ */\n    modifier onlyManufacturer(bytes32 _manufacturerId) {\n        require(manufacturers[_manufacturerId].owner == msg.sender, \"Only manufacturer can call this function\");\n        _;\n    }\n\n    /* ============ State Variables ============ */\n    mapping(bytes32 => EnrollmentInfo) internal enrollments;\n    mapping(bytes32 => ManufacturerInfo) internal manufacturers;\n    \n    /* ============ Constructor ============ */\n    /**\n     * @dev Constructor for ManufacturerRegistry. Sets owner to governance address.\n     *\n     * @param _governance               Address of governance\n     */\n    constructor(address _governance) \n        Ownable2Step()\n    {\n        _transferOwnership(_governance);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @dev ONLY MANUFACTURER: Adds a new enrollment for an active manufacturer. Enrollment is assigned an id which is returned. Only owner address\n     * associated with _manufacturerId can call this function. An \"active\" manufacturer is one with registered=true and a non-zero owner address.\n     *\n     * @param _manufacturerId               Bytes32 identifier for manufacturer (i.e. could be hash of manufacturer name)\n     * @param _certSigner                   Address of certificate signer for this enrollment\n     * @param _authModel                    Address of contract that implements example signature validation for a chip\n     * @param _enrollmentAuthModel          Address of contract that implements example signature validation for manufacturerCertificates\n     * @param _chipValidationDataUri        URI pointing to location of off-chain data required to validate chip is part of manufacturer enrollment\n     * @param _bootloaderApp                Bootloader app for this enrollment\n     * @param _chipModel                    Chip model for this enrollment\n     * @return enrollmentId                 Id of enrollment\n     */\n\n    function addChipEnrollment(\n        bytes32 _manufacturerId,\n        address _certSigner,\n        address _authModel,\n        IEnrollmentAuthModel _enrollmentAuthModel,\n        string calldata _chipValidationDataUri,\n        string calldata _bootloaderApp,\n        string calldata _chipModel\n    ) \n        external\n        onlyManufacturer(_manufacturerId)\n        returns (bytes32 enrollmentId)\n    {\n        require(_certSigner != address(0), \"Invalid certificate signer address\");\n        require(_authModel != address(0), \"Invalid auth model address\");\n        require(address(_enrollmentAuthModel) != address(0), \"Invalid enrollment auth model address\");\n\n        enrollmentId = keccak256(abi.encodePacked(_manufacturerId, manufacturers[_manufacturerId].nonce));\n\n        enrollments[enrollmentId] = EnrollmentInfo({\n            manufacturerId: uint256(_manufacturerId),\n            manufacturerCertSigner: _certSigner,\n            authModel: _authModel,\n            enrollmentAuthModel: _enrollmentAuthModel,\n            chipValidationDataUri: _chipValidationDataUri,\n            bootloaderApp: _bootloaderApp,\n            chipModel: _chipModel,\n            active: true\n        });\n\n        manufacturers[_manufacturerId].enrollments.push(enrollmentId);\n        manufacturers[_manufacturerId].nonce++;\n\n        emit EnrollmentAdded(\n            _manufacturerId,\n            enrollmentId,\n            _certSigner,\n            _authModel,\n            _enrollmentAuthModel,\n            _chipValidationDataUri,\n            _bootloaderApp,\n            _chipModel\n        );\n\n    }\n\n    /**\n     * @dev ONLY MANUFACTURER: Updates the active status of an enrollment. Only owner address associated with _manufacturerId can call this function.\n     * \n     * @param _manufacturerId The manufacturer id associated with the enrollment\n     * @param _active Whether or not to set the enrollment as active\n     * @param _enrollmentId The enrollment id to update\n     */\n    function updateChipEnrollment(\n        bytes32 _manufacturerId, \n        bool _active, \n        bytes32 _enrollmentId\n    ) external onlyManufacturer(_manufacturerId) {\n        require(enrollments[_enrollmentId].manufacturerId == uint256(_manufacturerId), \"Wrong manufacturer for enrollment id\");\n        enrollments[_enrollmentId].active = _active;\n    }\n\n    /**\n     * @dev ONLY OWNER: Registers a new manufacturer. Manufacturer is marked as registered forever once added so that history can't be mixed with\n     * other manufacturers. To burn access the owner param is set to the zero address (in removeManufacturer). A manufacturer is considered \"new\"\n     * if registered=false.\n     *\n     * @param _manufacturerId           Bytes32 identifier for manufacturer (i.e. could be hash of manufacturer name)\n     * @param _owner                    Address of Perp Vault contract\n     */\n    function addManufacturer(bytes32 _manufacturerId, address _owner) external onlyOwner {\n        require(!manufacturers[_manufacturerId].registered, \"Manufacturer already registered\");\n        require(_owner != address(0), \"Invalid owner address\");\n\n        manufacturers[_manufacturerId].owner = _owner;\n        manufacturers[_manufacturerId].registered = true;\n\n        emit ManufacturerAdded(_manufacturerId, _owner);\n    }\n\n    /**\n     * @dev ONLY OWNER: Removes an active manufacturer putting their history in read-only mode. In order to remove access we burn the owner key,\n     * this prevents history from being mixed in case a new manufacturer accidentally wants to use an old ID (it would revert and they would\n     * need to choose an new ID).\n     *\n     * @param _manufacturerId           Bytes32 identifier for manufacturer (i.e. could be hash of manufacturer name)\n     */\n    function removeManufacturer(bytes32 _manufacturerId) external onlyOwner {\n        require(manufacturers[_manufacturerId].owner != address(0), \"Manufacturer not registered\");\n\n        // We don't change registered to false in order to make sure that the manufacturer name is not reused, thus mixing history\n        delete manufacturers[_manufacturerId].owner;\n\n        emit ManufacturerRemoved(_manufacturerId);\n    }\n\n    /**\n     * @dev ONLY MANUFACTURER: Updates the owner address for a manufacturer. Only owner address associated with _manufacturerId can call this\n     * function.\n     *\n     * @param _manufacturerId           Bytes32 identifier for manufacturer (i.e. could be hash of manufacturer name)\n     * @param _newOwner                 Address of new owner\n     */\n    function updateManufacturerOwner(bytes32 _manufacturerId, address _newOwner) external onlyManufacturer(_manufacturerId) {\n        require(_newOwner != address(0), \"Invalid owner address\");\n\n        manufacturers[_manufacturerId].owner = _newOwner;\n        emit ManufacturerOwnerUpdated(_manufacturerId, _newOwner);\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     @dev Validate that the manufacturer has signed the current chainId and chipId to produce the certficate.\n\n     * @param _enrollmentId             bytes32 identifier of the manaufacturer enrollment\n     * @param _chipId                   Public key associated with the chip\n     * @param _manufacturerCertificate  Manufacturer certificate for the chip\n     */\n\n    function isEnrolledChip(\n        bytes32 _enrollmentId,\n        address _chipId,\n        bytes calldata _manufacturerCertificate,\n        bytes calldata _payload\n    )\n        external\n        view\n        virtual\n        returns (bool)\n    {\n        IEnrollmentAuthModel authModel = enrollments[_enrollmentId].enrollmentAuthModel;\n        return authModel.verifyManufacturerCertificate(\n            _chipId, enrollments[_enrollmentId].manufacturerCertSigner, \n            _manufacturerCertificate,\n            _payload\n        );\n    }\n\n    function isValidEnrollment(bytes32 _enrollmentId) external view returns (bool) {\n        return enrollments[_enrollmentId].active;\n    }\n\n    function getManufacturerInfo(bytes32 _manufacturerId) external view returns (ManufacturerInfo memory) {\n        return manufacturers[_manufacturerId];\n    }\n\n    function getEnrollmentInfo(bytes32 _enrollmentId) public view returns (EnrollmentInfo memory) {\n        return enrollments[_enrollmentId];\n    }\n\n    function getEnrollmentBootloaderApp(bytes32 _enrollmentId) external view returns (string memory) {\n        return getEnrollmentInfo(_enrollmentId).bootloaderApp;\n    }\n}\n"
    },
    "contracts/mocks/AccountMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { IERC1271 } from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport { IERC721Receiver } from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport { IPBT } from \"../token/IPBT.sol\";\n\ncontract AccountMock is IERC1271 {\n\n    using ECDSA for bytes32;\n\n    bytes4 public constant MAGIC_VALUE = 0x1626ba7e;\n\n    address public publicKey;\n    IPBT public chipRegistry;\n\n    constructor(address _publicKey, address _chipRegistry) {\n        publicKey = _publicKey;\n        chipRegistry = IPBT(_chipRegistry);\n    }\n\n    function transferTokenWithChip(\n        bytes calldata signatureFromChip,\n        uint256 blockNumberUsedInSig,\n        bool useSafeTransferFrom\n    )\n        external\n    {\n        chipRegistry.transferTokenWithChip(signatureFromChip, blockNumberUsedInSig, useSafeTransferFrom);\n    }\n\n    function transferToken(\n        address chipId,\n        bytes calldata signatureFromChip,\n        uint256 blockNumberUsedInSig,\n        bool useSafeTransferFrom,\n        bytes calldata payload\n    )\n        external\n    {\n        chipRegistry.transferToken(chipId, signatureFromChip, blockNumberUsedInSig, useSafeTransferFrom, payload);\n    }\n\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external view override returns (bytes4) {\n        if (_hash.recover(_signature) == publicKey) {\n            return MAGIC_VALUE;\n        } else {\n            return 0xffffffff;\n        }\n    }\n\n    function onERC721Received(\n        address /*operator*/,\n        address /*from*/,\n        uint256 /*tokenId*/,\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/mocks/ChipRegistryMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { ChipRegistry } from \"../ChipRegistry.sol\";\nimport { PBTSimple } from \"../token/PBTSimple.sol\";\nimport { IChipRegistry } from \"../interfaces/IChipRegistry.sol\";\nimport { IDeveloperRegistry } from \"../interfaces/IDeveloperRegistry.sol\";\nimport { IERS } from \"../interfaces/IERS.sol\";\nimport { IProjectRegistrar } from \"../interfaces/IProjectRegistrar.sol\";\nimport { IServicesRegistry } from \"../interfaces/IServicesRegistry.sol\";\nimport { IManufacturerRegistry } from \"../interfaces/IManufacturerRegistry.sol\";\nimport { PBTSimpleMock } from \"./PBTSimpleMock.sol\";\n\ncontract ChipRegistryMock is ChipRegistry {\n    mapping(address=>bool) public chipIds;\n    mapping(address=>address) public chipOwners;\n\n    IServicesRegistry public servicesRegistry;\n    \n    constructor(\n        IManufacturerRegistry _manufacturerRegistry,\n        uint256 _maxLockinPeriod,\n        address _migrationSigner\n    )\n        ChipRegistry(_manufacturerRegistry, _maxLockinPeriod, _migrationSigner)\n    {}\n\n    function initializeMock(IERS _ers, IServicesRegistry _servicesRegistry, IDeveloperRegistry _developerRegistry) external {\n        ers = _ers;\n        servicesRegistry = _servicesRegistry;\n        developerRegistry = _developerRegistry;\n    }\n\n    // Note: this originally set PBT chip state, but we currently bypass that for simpler testing\n    function mockAddChip(address _chipId, address _owner) external {\n        chipIds[_chipId] = true;\n        chipOwners[_chipId] = _owner;\n    }\n\n    function setInitialService(\n        address _chipId, \n        bytes32 _serviceId,\n        uint256 _timelock\n    ) external {\n        servicesRegistry.setInitialService(_chipId, _serviceId, _timelock);\n    }\n\n    function ownerOf(address _chipId) public view override(ChipRegistry) returns (address) {\n        // Not a great way to appropach this for testing...see `ownerOf` in ChipRegistry.sol\n        require(chipOwners[_chipId] != address(0), \"Chip not added\");\n        return chipOwners[_chipId];\n    }\n}\n"
    },
    "contracts/mocks/ChipValidationsMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { ChipValidations } from \"../lib/ChipValidations.sol\";\n\ncontract ChipValidationsMock {\n\n    constructor() {}\n\n    function validateSignatureAndExpiration(\n        address _chipId,\n        uint256 _commitBlock,\n        uint256 _maxBlockWindow,\n        bytes memory _payload,\n        bytes memory _signature\n    )\n        external\n        view\n    {\n        ChipValidations.validateSignatureAndExpiration(\n            _chipId,\n            _commitBlock,\n            _maxBlockWindow,\n            _payload,\n            _signature\n        );\n    }\n}\n"
    },
    "contracts/mocks/DeveloperRegistrarMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { DeveloperRegistrar } from \"../DeveloperRegistrar.sol\";\nimport { IChipRegistry } from \"../interfaces/IChipRegistry.sol\";\nimport { IERS } from \"../interfaces/IERS.sol\";\nimport { IDeveloperRegistry } from \"../interfaces/IDeveloperRegistry.sol\";\nimport { IServicesRegistry } from \"../interfaces/IServicesRegistry.sol\";\n\ncontract DeveloperRegistrarMock is DeveloperRegistrar {\n\n    constructor(\n        IChipRegistry _chipRegistry,\n        IERS _ers,\n        IDeveloperRegistry _developerRegistry,\n        IServicesRegistry _servicesRegistry\n    )\n        DeveloperRegistrar(\n            _chipRegistry,\n            _ers,\n            _developerRegistry,\n            _servicesRegistry\n        )\n    {}\n\n    function addMaliciousProject(address _projectRegistrar, bytes32 _projectRootNode) external {\n        projects.push(_projectRegistrar);\n        projectIndex[_projectRegistrar] = projects.length - 1;\n        emit ProjectAdded(_projectRegistrar, _projectRootNode);\n    }\n}\n"
    },
    "contracts/mocks/DeveloperRegistryMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { DeveloperRegistry } from \"../DeveloperRegistry.sol\";\nimport { IDeveloperRegistrar } from \"../interfaces/IDeveloperRegistrar.sol\";\nimport { IERS } from \"../interfaces/IERS.sol\";\n\ncontract DeveloperRegistryMock is DeveloperRegistry {\n\n    constructor(address _governance) \n        DeveloperRegistry(_governance)\n    {}\n\n    function addMockRegistrar(address _newRegistrar, bytes32 _nameHash) external {\n        bytes32 registrarRootNode = ersRegistry.createSubnodeRecord(ROOT_NODE, _nameHash, _newRegistrar, _newRegistrar);\n        \n        IDeveloperRegistrar(_newRegistrar).initialize(msg.sender, registrarRootNode);\n\n        isDeveloperRegistrar[_newRegistrar] = true;\n        developerRegistrars.push(_newRegistrar);\n    }\n\n    function addMockRegistrarEOA(address _newRegistrar, bytes32 _nameHash) external {\n        ersRegistry.createSubnodeRecord(ROOT_NODE, _nameHash, _newRegistrar, _newRegistrar);\n\n        isDeveloperRegistrar[_newRegistrar] = true;\n        developerRegistrars.push(_newRegistrar);\n    }\n}\n"
    },
    "contracts/mocks/InterfaceIdGetterMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport { IChipRegistry } from \"../interfaces/IChipRegistry.sol\";\nimport { IPBT } from \"../token/IPBT.sol\";\nimport { IProjectRegistrar } from \"../interfaces/IProjectRegistrar.sol\";\n\ncontract InterfaceIdGetterMock {\n    constructor() {}\n\n    function getERC165InterfaceId() external pure returns (bytes4) {\n        return type(IERC165).interfaceId;\n    }\n\n    function getERC721InterfaceId() external pure returns (bytes4) {\n        return type(IERC721).interfaceId;\n    }\n\n    function getERC721MetadataInterfaceId() external pure returns (bytes4) {\n        return type(IERC721Metadata).interfaceId;\n    }\n\n    function getPBTInterfaceId() external pure returns (bytes4) {\n        return type(IPBT).interfaceId;\n    }\n\n    function getProjectRegistrarInterfaceId() external pure returns (bytes4) {\n        return type(IProjectRegistrar).interfaceId;\n    }\n\n    function getChipRegistryInterfaceId() external pure returns (bytes4) {\n        return type(IChipRegistry).interfaceId;\n    }\n}\n"
    },
    "contracts/mocks/PBTSimpleMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { PBTSimple } from \"../token/PBTSimple.sol\";\nimport { IPBT } from \"../token/IPBT.sol\";\nimport { ITransferPolicy } from \"../interfaces/ITransferPolicy.sol\";\n\ncontract PBTSimpleMock is PBTSimple {\n    constructor(string memory _name, string memory _symbol, string memory _baseURI, uint256 maxBlockWindow, ITransferPolicy _transferPolicy) \n        PBTSimple(_name, _symbol, _baseURI, maxBlockWindow, _transferPolicy)\n    {}\n\n    function testMint(\n        address _to,\n        address _chipId,\n        bytes32 _ersNode\n    ) external {\n        _mint(_to, _chipId, _ersNode);\n    }\n\n    function setTransferPolicy(\n        ITransferPolicy _newPolicy\n    )\n        public\n    {\n        _setTransferPolicy(_newPolicy);\n    }\n\n    /**\n     * \n     * @param _interfaceId The interface ID to check for\n     */\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        override(PBTSimple)\n        virtual\n        returns (bool)\n    {\n        return\n            _interfaceId == type(IPBT).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}\n"
    },
    "contracts/mocks/ProjectRegistrarMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { BaseProjectRegistrar } from \"../project-registrars/BaseProjectRegistrar.sol\";\nimport { IChipRegistry } from \"../interfaces/IChipRegistry.sol\";\nimport { IDeveloperRegistrar } from \"../interfaces/IDeveloperRegistrar.sol\";\nimport { IERS } from \"../interfaces/IERS.sol\";\nimport { IPBT } from \"../token/IPBT.sol\";\nimport { IProjectRegistrar } from \"../interfaces/IProjectRegistrar.sol\";\nimport { ITransferPolicy } from \"../interfaces/ITransferPolicy.sol\";\nimport { PBTSimpleMock } from \"./PBTSimpleMock.sol\";\n\ncontract ProjectRegistrarMock is BaseProjectRegistrar, PBTSimpleMock {\n\n    /* ============ Structs ============ */\n    struct ProjectChipAddition {\n        address chipId;\n        address chipOwner;\n        bytes32 nameHash; // A label used to identify the chip; in a PBT imlementation, this might match the tokenId\n        IChipRegistry.ManufacturerValidation manufacturerValidation;\n        bytes custodyProof;\n    }\n\n    constructor(IChipRegistry _chipRegistry, IERS _ers, IDeveloperRegistrar _developerRegistrar)\n        BaseProjectRegistrar(_chipRegistry, _ers, _developerRegistrar)\n        PBTSimpleMock(\"SimplePBT\", \"PBT\", \"pbt.com\", 5, ITransferPolicy(address(0)))\n    {}\n\n    /**\n     * @notice ONLY OWNER: Allow the project manager to add chips to the project.\n     * \n     * @param _chips    Array of information needed for claiming chips\n     */\n    function addChips(\n        ProjectChipAddition[] calldata _chips\n    ) \n        external\n        onlyOwner()\n    {\n        for (uint256 i = 0; i < _chips.length; i++) {\n            ProjectChipAddition memory chip = _chips[i];\n            _addChip(\n                chip.chipId,\n                chip.chipOwner,\n                chip.nameHash,\n                chip.manufacturerValidation,\n                chip.custodyProof\n            );\n            _mint(chip.chipOwner, chip.chipId, chip.nameHash);\n        }\n    }\n\n    function setChipNodeOwnerMock(\n        address _chipId,\n        address _newOwner\n    )\n        external\n        onlyOwner()\n    {\n        chipRegistry.setChipNodeOwner(_chipId, _newOwner);\n    }\n\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        override(BaseProjectRegistrar, PBTSimpleMock)\n        returns (bool)\n    {\n        return\n            _interfaceId == type(IProjectRegistrar).interfaceId ||\n            _interfaceId == type(IPBT).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}\n"
    },
    "contracts/mocks/TransferPolicyMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { ITransferPolicy } from \"../interfaces/ITransferPolicy.sol\";\n\ncontract TransferPolicyMock is ITransferPolicy {\n\n    struct CallInfo {\n        address chipId;\n        address sender;\n        address chipOwner;\n        bytes payload;\n        bytes signature;\n    }\n\n    CallInfo public callInfo;\n    /* ============ Constructor ============ */\n\n    constructor() {}\n    \n    /* ============ External Functions ============ */\n\n    function authorizeTransfer(\n        address _chipId,\n        address _sender,\n        address _chipOwner,\n        bytes calldata _payload,\n        bytes calldata _signature\n    )\n        external\n        override\n    {\n        callInfo = CallInfo({\n            chipId: _chipId,\n            sender: _sender,\n            chipOwner: _chipOwner,\n            payload: _payload,\n            signature: _signature\n        });\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/project-registrars/BaseProjectRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { Ownable2Step } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nimport { ChipValidations } from \"../lib/ChipValidations.sol\";\nimport { IChipRegistry } from \"../interfaces/IChipRegistry.sol\";\nimport { IERS } from \"../interfaces/IERS.sol\";\nimport { IProjectRegistrar } from \"../interfaces/IProjectRegistrar.sol\";\nimport { IDeveloperRegistrar } from \"../interfaces/IDeveloperRegistrar.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @title BaseProjectRegistrar\n * @author Arx Research\n * \n * @notice Base contract for ProjectRegistrars. Contains common functionality for all ProjectRegistrars including setting the root node\n * and claiming chips.\n */\ncontract BaseProjectRegistrar is Ownable2Step, ERC165, IProjectRegistrar {\n    using ChipValidations for address;\n\n    /* ============ Events ============ */\n    // Emitted when a new root node has been set\n    event RootNodeSet(bytes32 _rootNode);\n\n    /* ============ Modifiers ============ */\n    modifier onlyDeveloperRegistrar() {\n        require(address(developerRegistrar) == msg.sender, \"onlyDeveloperRegistrar: Only the contract's Developer Registrar can call this function\");\n        _;\n    }\n\n    /* ============ State Variables ============ */\n    IChipRegistry public immutable chipRegistry; \n    IERS public immutable ers; \n    IDeveloperRegistrar public immutable developerRegistrar; \n    \n    bytes32 public rootNode;                    // It is the hash(hash(projectName), node(developer.ers))\n\n    /* ============ Constructor ============ */\n    /**\n     * @param _chipRegistry             The chip registry of the ERS system being used\n     * @param _ers                      The ERS registry of the ERS system being used\n     * @param _developerRegistrar       The DeveloperRegistrar that made this project\n     */\n    constructor(\n        IChipRegistry _chipRegistry, \n        IERS _ers, \n        IDeveloperRegistrar _developerRegistrar\n    ) \n        Ownable2Step() \n    {\n        chipRegistry = _chipRegistry;\n        ers = _ers;\n        developerRegistrar = _developerRegistrar;\n    }\n\n    /* ============ External Admin Functions ============ */\n\n    /**\n     * @dev ONLY DEVELOPER REGISTRAR: Set the root node for this project (ie project.developer.ers)\n     * \n     * @param _rootNode The root node for this project\n     */\n    function setRootNode(bytes32 _rootNode) onlyDeveloperRegistrar() external override {\n        require(rootNode == bytes32(0), \"Root node already set\");\n        rootNode = _rootNode;\n        emit RootNodeSet(_rootNode);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice Lookup a chip owner via ERS; adding on ProjectRegistrar enforces that collections\n     * must (1) allow ownership lookups and (2) increase the probability ownership truth is \n     * contained in ERS.\n     * \n     * @param _chipId                   Address of the chip being claimed\n     */\n    function ownerOf(address _chipId) \n        external \n        view \n        returns (address) \n    {\n        bytes32 chipNode = chipRegistry.node(_chipId);\n        return ers.getOwner(chipNode);\n    }\n\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(ERC165)\n        returns (bool)\n    {\n        return _interfaceId == type(IProjectRegistrar).interfaceId ||\n        super.supportsInterface(_interfaceId);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Allow a chip holder to name chip to the ERS and enroll it to the Chip Registry\n     * \n     * @param _chipId                   Address of the chip being claimed\n     * @param _chipOwner                Intended owner of the chip being claimed\n     * @param _manufacturerValidation   Struct with needed info for chip's manufacturer validation\n     * @param _custodyProof             Proof of custody for the chip\n     */\n    function _addChip(\n        address _chipId,\n        address _chipOwner,\n        bytes32 _nameHash,\n        IChipRegistry.ManufacturerValidation memory _manufacturerValidation,\n        bytes memory _custodyProof\n    ) \n        internal\n    {\n        // Registrar calls the addChip function on the ChipRegistry\n        chipRegistry.addChip(\n            _chipId, \n            _chipOwner, \n            _nameHash,\n            _manufacturerValidation, \n            _custodyProof\n        );\n    }\n}\n"
    },
    "contracts/project-registrars/PBTSimpleProjectRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { BaseProjectRegistrar } from \"./BaseProjectRegistrar.sol\";\nimport { ChipValidations } from \"../lib/ChipValidations.sol\";\nimport { IChipRegistry } from \"../interfaces/IChipRegistry.sol\";\nimport { IERS } from \"../interfaces/IERS.sol\";\nimport { IProjectRegistrar } from \"../interfaces/IProjectRegistrar.sol\";\nimport { IDeveloperRegistrar } from \"../interfaces/IDeveloperRegistrar.sol\";\n\nimport { PBTSimple } from \"../token/PBTSimple.sol\";\nimport { IPBT } from \"../token/IPBT.sol\";\nimport { ITransferPolicy } from \"../interfaces/ITransferPolicy.sol\";\n\n/**\n * @title BaseProjectRegistrar\n * @author Arx Research\n * \n * @notice Base contract for ProjectRegistrars. Contains common functionality for all ProjectRegistrars including setting the root node\n * and claiming chips.\n */\ncontract PBTSimpleProjectRegistrar is BaseProjectRegistrar, PBTSimple {\n    using ChipValidations for address;\n\n    /* ============ Structs ============ */\n    struct ProjectChipAddition {\n        address chipId;\n        address chipOwner;\n        bytes32 nameHash; // A label used to identify the chip; in a PBT imlementation, this might match the tokenId\n        IChipRegistry.ManufacturerValidation manufacturerValidation;\n        bytes custodyProof;\n    }\n    \n    /* ============ Constructor ============ */\n    /**\n     * @param _chipRegistry             The chip registry of the ERS system being used\n     * @param _ers                      The ERS registry of the ERS system being used\n     * @param _developerRegistrar       The DeveloperRegistrar that made this project\n     * @param _name                     The name of the custom PBT token\n     * @param _symbol                   The symbol of the custom PBT token\n     */\n    constructor(\n        IChipRegistry _chipRegistry, \n        IERS _ers, \n        IDeveloperRegistrar _developerRegistrar,\n        string memory _name,\n        string memory _symbol,\n        string memory _baseURI,\n        uint256 _maxBlockWindow,\n        ITransferPolicy _transferPolicy\n    ) \n        PBTSimple(_name, _symbol, _baseURI, _maxBlockWindow, _transferPolicy)\n        BaseProjectRegistrar(\n            _chipRegistry,\n            _ers,\n            _developerRegistrar\n        )\n    {}\n\n    /* ============ External Admin Functions ============ */\n\n    /**\n     * @dev Owner set the transfer policy for PBT.\n     * @param _newPolicy        The address of the new transfer policy. We allow the zero address in case owner doesn't want to allow xfers.\n     */\n    function setTransferPolicy(\n        ITransferPolicy _newPolicy\n    )\n        public\n        onlyOwner()\n    {\n        _setTransferPolicy(_newPolicy);\n    }\n\n    /**\n     * @notice ONLY OWNER: Allows the contract owner to update the base URI for the PBT tokens.\n     *\n     * @param updatedBaseURI The new base URI to set for the tokens.\n     */\n    function setBaseURI(\n        string memory updatedBaseURI\n    ) \n        public \n        onlyOwner() \n    {\n        baseURI = updatedBaseURI;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice Included for compliance with EIP-5791 standard but left unimplemented to ensure transfer policies can't be ignored.\n     */\n    function transferTokenWithChip(\n        bytes calldata /*signatureFromChip*/,\n        uint256 /*blockNumberUsedInSig*/,\n        bool /*useSafeTransfer*/\n    )\n        public\n        virtual\n        override(PBTSimple)\n    {\n        revert(\"Not implemented\");\n    }\n\n    /**\n     * @notice Allow a user to transfer a chip to a new owner, new owner must submit transaction. Use ChipPBT logic which calls\n     * TransferPolicy to execute the transfer of the PBT and chip. Update chip's ERS node in order to keep data consistency. EIP-1271\n     * compatibility should be implemented in the chip's TransferPolicy contract.\n     *\n     * @param chipId                Chip ID (address) of chip being transferred\n     * @param signatureFromChip     Signature of keccak256(msg.sender, blockhash(blockNumberUsedInSig), _payload) signed by chip\n     *                              being transferred\n     * @param blockNumberUsedInSig  Block number used in signature\n     * @param useSafeTransferFrom   Indicates whether to use safeTransferFrom or transferFrom\n     * @param payload               Encoded payload containing data required to execute transfer. Data structure will be dependent\n     *                              on implementation of TransferPolicy\n     */\n    function transferToken(\n        address chipId,\n        bytes calldata signatureFromChip,\n        uint256 blockNumberUsedInSig,\n        bool useSafeTransferFrom,\n        bytes calldata payload\n    ) \n        public\n        override(PBTSimple)\n    {\n        // Validations happen in PBTSimple / TransferPolicy\n        PBTSimple.transferToken(chipId,  signatureFromChip, blockNumberUsedInSig, useSafeTransferFrom, payload);\n        chipRegistry.setChipNodeOwner(chipId, msg.sender);\n    }    \n\n    /**\n     * @dev ONLY CHIP OWNER (enforced in PBTSimple): Sets the owner for a chip. Chip owner must submit transaction\n     * along with a signature from the chipId commiting to a block the signature was generated. This is to prevent\n     * any replay attacks. If the transaction isn't submitted within the MAX_BLOCK_WINDOW from the commited block\n     * this function will revert. Additionally, the chip's ERS node owner is updated to maintain state consistency.\n     *\n     * @param _chipId           The chipId to set the owner for\n     * @param _newOwner         The address of the new chip owner\n     * @param _commitBlock      The block the signature is tied to (used to put a time limit on the signature)\n     * @param _signature        The signature generated by the chipId (should just be a signature of the commitBlock)\n     */\n    function setOwner(\n        address _chipId,\n        address _newOwner,\n        uint256 _commitBlock,\n        bytes calldata _signature\n    )\n        public\n        override\n    {   \n        // Validations happen in PBTSimple, ERC721 doesn't allow transfers to the zero address\n        PBTSimple.setOwner(_chipId, _newOwner, _commitBlock, _signature);\n        chipRegistry.setChipNodeOwner(_chipId, _newOwner);\n    }\n\n    /**\n     * @notice ONLY OWNER: Allow the project manager to add chips to the project.\n     * \n     * @param _chips    Array of information needed for claiming chips\n     */\n    function addChips(\n        ProjectChipAddition[] calldata _chips\n    ) \n        external\n        onlyOwner()\n    {\n        for (uint256 i = 0; i < _chips.length; i++) {\n            ProjectChipAddition memory chip = _chips[i];\n            _addChip(\n                chip.chipId,\n                chip.chipOwner,\n                chip.nameHash,\n                chip.manufacturerValidation,\n                chip.custodyProof\n            );\n            _mint(\n                chip.chipOwner,\n                chip.chipId,\n                chip.nameHash\n            );\n        }\n    }\n\n    /**\n     * \n     * @param _interfaceId The interface ID to check for\n     */\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        override(BaseProjectRegistrar, PBTSimple)\n        returns (bool)\n    {\n        return\n            _interfaceId == type(IProjectRegistrar).interfaceId ||\n            _interfaceId == type(IPBT).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}\n\n\n\n"
    },
    "contracts/ServicesRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\nimport { Bytes32ArrayUtils } from \"./lib/Bytes32ArrayUtils.sol\";\nimport { IERC165, ERC165 } from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport { IChipRegistry } from \"./interfaces/IChipRegistry.sol\";\nimport { IServicesRegistry } from \"./interfaces/IServicesRegistry.sol\";\n\nimport \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\n/**\n * @title ServicesRegistry\n * @author Arx Research\n *\n * @notice Contract for creating and updating services for service owners and adding/removing services for chip owners. Services\n * contain a recordType and record content. The recordType is intended to be a standardized off-chain string that clients\n * can use to interpret the record content. Record types could be a tokenUri, a URL, a smart contract, or any other value.\n * Chips are always enrolled in a primary service, in most cases this is the service the chip should resolve to when\n * scanned. Additionally, a chip can be enrolled in secondary services that allow it to access additional functionality.\n * Primary services have a timelock that must expire before the primary service can be changed. Secondary services can be\n * added and removed at any time. The primary service cannot be one of the chip's secondary services.\n */\ncontract ServicesRegistry is IServicesRegistry, ERC165, EIP712 {\n    using Bytes32ArrayUtils for bytes32[];\n    using ECDSA for bytes;\n    using SignatureChecker for address;\n\n    /* ============ Events ============ */\n\n    event ServiceCreated(bytes32 indexed serviceId, address indexed owner);\n    event ServiceRecordAdded(bytes32 indexed serviceId, bytes32 indexed recordType, bytes content, bool appendId);\n    event ServiceRecordEdited(bytes32 indexed serviceId, bytes32 indexed recordType, bytes newContent, bool appendId);\n    event ServiceRecordRemoved(bytes32 indexed serviceId, bytes32 indexed recordType);\n    event ServiceOwnershipTransferred(bytes32 indexed serviceId, address oldOwner, address newOwner);\n\n    event PrimaryServiceUpdated(\n        address indexed chipId,\n        bytes32 indexed newPrimaryService,\n        bytes32 oldPrimaryService,\n        uint256 serviceTimelock\n    );\n    event SecondaryServiceAdded(address indexed chipId, bytes32 indexed serviceId);\n    event SecondaryServiceRemoved(address indexed chipId, bytes32 indexed serviceId);\n\n    /* ============ Structs ============ */\n\n    struct RecordContent {\n        bool enabled;                   // Need to have an enabled flag because we can't rely on the content field containing info\n        bool appendId;                  // Indicates whether _chipId should be appended to end of the record content\n        bytes content;\n    }\n\n    struct ServiceRecord {\n        bytes32 recordType;\n        bytes content;\n        bool appendId;                  // Indicates whether _chipId should be appended to end of the record content\n    }\n\n    struct ServiceInfo {\n        address owner;\n        bytes32[] recordTypes;\n    }\n\n    struct ChipServices {\n        bytes32 primaryService;\n        uint256 serviceTimelock;        // Timelock before which the primaryService cannot be changed\n        bytes32[] secondaryServices;\n    }\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyServiceOwner(bytes32 _serviceId) {\n        require(serviceInfo[_serviceId].owner == msg.sender, \"Caller must be service owner\");\n        _;\n    }\n\n    modifier onlyChipOwner(address _chipId) {\n        require(chipRegistry.ownerOf(_chipId) == msg.sender, \"Caller must be chip owner\");\n        _;\n    }\n\n    /* ============ Constants ============ */\n    // Match signature version to project version.\n    string public constant EIP712_SIGNATURE_DOMAIN = \"ERS\";\n    string public constant EIP712_SIGNATURE_VERSION = \"2.0.0\";\n\n    /* ============ State Variables ============ */\n\n    IChipRegistry public immutable chipRegistry;\n    uint256 public immutable maxBlockWindow;\n\n    mapping(address=>ChipServices) public chipServices;\n    mapping(address=>mapping(bytes32=>bool)) public enrolledServices;\n    mapping(bytes32=>ServiceInfo) public serviceInfo;\n    mapping(bytes32=>mapping(bytes32=>RecordContent)) public serviceRecords;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructor for ServicesRegistry\n     *\n     * @param _chipRegistry         Address of the ChipRegistry contract\n     * @param _maxBlockWindow       The maximum amount of blocks a signature used for updating chip table is valid for\n    */\n    constructor(IChipRegistry _chipRegistry, uint256 _maxBlockWindow) \n        EIP712(EIP712_SIGNATURE_DOMAIN, EIP712_SIGNATURE_VERSION) \n    {\n        chipRegistry = _chipRegistry;\n        maxBlockWindow = _maxBlockWindow;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice Creates a new service. Services contain multiple different record types which could be a tokenUri, a URL or any other\n     * unstructured content. Each record is identified by its recordType. We expect off-chain standardization around recordTypes and\n     * do not maintain a canonical on-chain list of records. Associated with each recordType is a content string which is intended\n     * to be interpreted by the client. The service ID must be unique and the service records must not contain duplicate record types.\n     *\n     * @param _serviceId        The service ID\n     * @param _serviceRecords   The service records\n     */\n    function createService(bytes32 _serviceId, ServiceRecord[] calldata _serviceRecords) external {\n        require(_serviceId != bytes32(0), \"Invalid ServiceId\");\n        require(!isService(_serviceId), \"ServiceId already taken\");\n\n        serviceInfo[_serviceId].owner = msg.sender;\n\n        for (uint256 i = 0; i < _serviceRecords.length; ++i) {\n            _addServiceRecord(_serviceId, _serviceRecords[i]);\n        }\n\n        emit ServiceCreated(_serviceId, msg.sender);\n    }\n\n    /**\n     * @notice ONLY SERVICE OWNER: Adds new service records to an existing service. The service records must not contain duplicate record types or\n     * have an existing record of the same type. Don't need to explicitly check that the service has been created because if it has then there\n     * should be an owner address if not then the owner address is the zero address thus it will revert.\n     *\n     * @param _serviceId        The service ID\n     * @param _serviceRecords   The service records\n     */\n    function addServiceRecords(bytes32 _serviceId, ServiceRecord[] calldata _serviceRecords) external onlyServiceOwner(_serviceId) {\n        for (uint256 i = 0; i < _serviceRecords.length; ++i) {\n            _addServiceRecord(_serviceId, _serviceRecords[i]);\n        }\n    }\n\n    /**\n     * @notice ONLY SERVICE OWNER: Edits existing service records for an existing service. The service records must not contain duplicate record\n     * types.\n     *\n     * @param _serviceId        The service ID\n     * @param _serviceRecords   The service records\n     */\n    function editServiceRecords(bytes32 _serviceId, ServiceRecord[] calldata _serviceRecords) external onlyServiceOwner(_serviceId) {\n        bytes32[] memory recordTypes = new bytes32[](_serviceRecords.length);   // Need to do duplication check so need to store in memory\n\n        mapping(bytes32=>RecordContent) storage record = serviceRecords[_serviceId];\n        for (uint256 i = 0; i < _serviceRecords.length; ++i) {\n            // Split up the fields because it saves some gas (~100 per record)\n            bytes32 recordType = _serviceRecords[i].recordType;\n            bytes memory content = _serviceRecords[i].content;\n            bool appendId = _serviceRecords[i].appendId;\n\n            require(record[recordType].enabled, \"Record type does not exist for service\");\n\n            record[recordType].content = content;\n            record[recordType].appendId = appendId;\n            recordTypes[i] = recordType;\n\n            emit ServiceRecordEdited(_serviceId, recordType, content, appendId);\n        }\n\n        require(!recordTypes.hasDuplicate(), \"Duplicate record types\");\n    }\n\n    /**\n     * @notice ONLY SERVICE OWNER: Removes existing service records for an existing service. The service records must not contain duplicate record\n     * types.\n     *\n     * @param _serviceId        The service ID\n     * @param _recordTypes      The record types to remove\n     */\n    function removeServiceRecords(bytes32 _serviceId, bytes32[] calldata _recordTypes) external onlyServiceOwner(_serviceId) {\n        mapping(bytes32=>RecordContent) storage record = serviceRecords[_serviceId];\n        for (uint256 i = 0; i < _recordTypes.length; ++i) {\n            bytes32 recordType = _recordTypes[i];\n\n            // Case covers if record didn't exist before function call or was deleted during function call\n            require(record[recordType].enabled, \"Record type does not exist for service\");\n\n            serviceInfo[_serviceId].recordTypes.removeStorage(recordType);\n\n            delete record[recordType];\n\n            emit ServiceRecordRemoved(_serviceId, recordType);\n        }\n    }\n\n    /**\n     * @notice ONLY SERVICE OWNER: Sets the service owner to a new address. The new address cannot be the zero address.\n     *\n     * @param _serviceId        The service ID\n     * @param _newOwner         The new owner address\n     */\n    function setServiceOwner(bytes32 _serviceId, address _newOwner) external onlyServiceOwner(_serviceId) {\n        require(_newOwner != address(0), \"Invalid address\");\n        require(msg.sender != _newOwner, \"Old and new owner are same address\");     // Checked that msg.sender == oldOwner in modifier\n\n        address oldOwner = serviceInfo[_serviceId].owner;\n\n        serviceInfo[_serviceId].owner = _newOwner;\n\n        emit ServiceOwnershipTransferred(_serviceId, oldOwner, _newOwner);\n    }\n\n    /**\n     * @notice ONLY CHIP REGISTRY: Sets the initial service for a chip. The service must exist and the passed _timelock must not be 0. If the\n     * current primaryService state is set to bytes32(0) then the chip has NOT been enrolled in a service and thus this function can be called. \n     *\n     * @param _chipId           The chip ID\n     * @param _serviceId        The service ID to enroll\n     * @param _timelock         Timestamp before which the primaryService cannot be changed\n     */\n    function setInitialService(\n        address _chipId,\n        bytes32 _serviceId,\n        uint256 _timelock\n    )\n        external\n        override\n    {\n        require(msg.sender == address(chipRegistry), \"Caller must be ChipRegistry\");\n\n        // NOTE: we don't want to check that the _timelock is greater than the current timestamp in case the claim happens after timelock expires\n        require(_timelock != 0, \"Timelock cannot be set to 0\");\n        require(chipServices[_chipId].primaryService == bytes32(0), \"Primary service already set\");\n        // Covers case where _serviceId == bytes32(0) since that can't be a service per createService\n        require(isService(_serviceId), \"Service does not exist\");\n        // chipServices[_chipId].primaryService = _serviceId;\n        // chipServices[_chipId].secondaryServices = new bytes32[](0);\n\n        chipServices[_chipId] = ChipServices({\n            primaryService: _serviceId,\n            serviceTimelock: _timelock,\n            secondaryServices: new bytes32[](0)\n        });\n\n        emit PrimaryServiceUpdated(_chipId, _serviceId, bytes32(0), _timelock);\n    }\n\n    /**\n     * @notice ONLY CHIP OWNER: Sets the primary service for the calling chip. In order for this function to succeed the following conditions\n     * must be met:\n     *  - The caller is the chip owner\n     *  - The new service must exist\n     *  - The new service must not be the same as the current primary service\n     *  - The new timelock must be greater than the current block timestamp\n     *  - The timelock for the previous primaryService must have expired\n     *  - The new service must not be enrolled as a secondary service for the chip\n     *  - The signature was generated by the chip\n     * This function can't be called until after the chip has been claimed and enrolled in a primary service (enforced by onlyChipOwner).\n     *\n     * @param _chipId           Address of chip removing secondary service\n     * @param _serviceId        New primary service ID\n     * @param _newTimelock      Timelock for the new primary service\n     * @param _commitBlock      The block the signature is tied to (used to put a time limit on the signature)\n     * @param _signature        The signature generated by the chipId (should just be a signature of the commitBlock)\n     */\n    function setNewPrimaryService(\n        address _chipId,\n        bytes32 _serviceId,\n        uint256 _newTimelock,\n        uint256 _commitBlock,\n        bytes calldata _signature\n    )\n        external\n        onlyChipOwner(_chipId)\n    {\n        bytes32 oldPrimaryService = chipServices[_chipId].primaryService;\n\n        require(chipServices[_chipId].serviceTimelock < block.timestamp, \"Timelock has not expired\");\n        require(_newTimelock > block.timestamp, \"Timelock must be greater than current timestamp\");\n\n        // Covers case where _serviceId == bytes32(0) since that can't be a service per createService\n        require(isService(_serviceId), \"Service does not exist\");\n        require(!enrolledServices[_chipId][_serviceId], \"Primary service cannot be secondary service\");\n        require(_serviceId != oldPrimaryService, \"Service already set as primary service\");\n\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n            keccak256(\"SetNewPrimaryService(uint256 commitBlock,bytes32 serviceId,uint256 newTimelock)\"),\n            _commitBlock,\n            _serviceId,\n            _newTimelock\n        )));\n        \n        _validateSignatureAndExpiration(\n            digest,\n            _chipId,\n            _commitBlock,\n            maxBlockWindow,\n            _signature\n        );\n\n        chipServices[_chipId].primaryService = _serviceId;\n        chipServices[_chipId].serviceTimelock = _newTimelock;\n\n        emit PrimaryServiceUpdated(_chipId, _serviceId, oldPrimaryService, _newTimelock);\n    }\n\n    /**\n     * @notice ONLY CHIP OWNER: Adds a secondary service for the calling chip. In order for this function to succeed the following conditions\n     * must be met:\n     *  - The caller is the chip owner\n     *  - The new service must exist\n     *  - The new service must not be enrolled as a secondary service for the chip\n     *  - The new service must not be the same as the primary service\n     *  - The signature was generated by the chip\n     * This function can't be called until after the chip has been claimed and enrolled in a primary service (enforced by onlyChipOwner).\n     *\n     * @param _chipId           Address of chip removing secondary service\n     * @param _serviceId        The service ID\n     * @param _commitBlock      The block the signature is tied to (used to put a time limit on the signature)\n     * @param _signature        The signature generated by the chipId (should just be a signature of the commitBlock)\n     */\n    function addSecondaryService(\n        address _chipId,\n        bytes32 _serviceId,\n        uint256 _commitBlock,\n        bytes calldata _signature\n    )\n        external\n        onlyChipOwner(_chipId)\n    {\n        require(isService(_serviceId), \"Service does not exist\");\n        require(!enrolledServices[_chipId][_serviceId], \"Service already enrolled\");\n        require(_serviceId != chipServices[_chipId].primaryService, \"Service already set as primary service\");\n\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n            keccak256(\"AddSecondaryService(uint256 commitBlock,bytes32 serviceId)\"),\n            _commitBlock,\n            _serviceId\n        )));\n        \n        _validateSignatureAndExpiration(\n            digest,\n            _chipId,\n            _commitBlock,\n            maxBlockWindow,\n            _signature\n        );\n\n        chipServices[_chipId].secondaryServices.push(_serviceId);\n        enrolledServices[_chipId][_serviceId] = true;\n\n        emit SecondaryServiceAdded(_chipId, _serviceId);\n    }\n\n    /**\n     * @notice ONLY CHIP OWNER: Removes a secondary service for the calling chip. In order for this function to succeed the following\n     * conditions must be met:\n     *  - The caller is the chip owner\n     *  - The service must exist\n     *  - The service must be enrolled as a secondary service for the chip\n     *  - The signature was generated by the chip\n     * This function can't be called until after the chip has been claimed and enrolled in a primary service (enforced by onlyChipOwner).\n     *\n     * @param _chipId           Address of chip removing secondary service\n     * @param _serviceId        The service ID\n     * @param _commitBlock      The block the signature is tied to (used to put a time limit on the signature)\n     * @param _signature        The signature generated by the chipId (should just be a signature of the commitBlock)\n     */\n    function removeSecondaryService(\n        address _chipId,\n        bytes32 _serviceId,\n        uint256 _commitBlock,\n        bytes calldata _signature\n    )\n        external\n        onlyChipOwner(_chipId)\n    {\n        require(isService(_serviceId), \"Service does not exist\");\n        require(enrolledServices[_chipId][_serviceId], \"Service not enrolled\");\n\n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n            keccak256(\"RemoveSecondaryService(uint256 commitBlock,bytes32 serviceId)\"),\n            _commitBlock,\n            _serviceId\n        )));\n        \n        _validateSignatureAndExpiration(\n            digest,\n            _chipId,   \n            _commitBlock,\n            maxBlockWindow,\n            _signature\n        );\n\n        chipServices[_chipId].secondaryServices.removeStorage(_serviceId);\n        enrolledServices[_chipId][_serviceId] = false;\n\n        emit SecondaryServiceRemoved(_chipId, _serviceId);\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     * Return information about owner and record types for a service\n     *\n     * @param _serviceId        The service ID\n     * @return                  ServiceInfo struct (owner and recordTypes)\n     */\n    function getServiceInfo(bytes32 _serviceId) external view returns (ServiceInfo memory) {\n        return serviceInfo[_serviceId];\n    }\n\n    /**\n     * Get the content of the given record type for a chip's primary service\n     *\n     * @param _chipId        The chip ID\n     * @param _recordType    The record type\n     * @return               bytes representing the content of the record\n     */\n    function getPrimaryServiceContentByRecordtype(\n        address _chipId,\n        bytes32 _recordType\n    )\n        external\n        view\n        override\n        returns (bytes memory)\n    {\n        bytes32 primaryService = chipServices[_chipId].primaryService;\n        RecordContent memory recordContent = serviceRecords[primaryService][_recordType];\n        return _createContentString(_chipId, recordContent.content, recordContent.appendId);\n    }\n\n    /**\n     * Get a list of all records for a given service\n     *\n     * @param _serviceId     The service ID\n     * @return records       List of ServiceRecords for the passed serviceId\n     */\n    function getServiceContent(address _chipId, bytes32 _serviceId) public view returns (Record[] memory records) {\n        bytes32[] memory recordTypes = serviceInfo[_serviceId].recordTypes;\n\n        uint256 recordTypesLength = recordTypes.length;\n        records = new Record[](recordTypesLength);\n        for (uint256 i = 0; i < recordTypesLength; ++i) {\n            bytes32 recordType = recordTypes[i];\n            RecordContent memory serviceContent = serviceRecords[_serviceId][recordType];\n            records[i] = Record({\n                recordType: recordType,\n                content: _createContentString(_chipId, serviceContent.content, serviceContent.appendId)\n            });\n        }\n    }\n\n    /**\n     * Get records for every secondary service and primary service for a chip. Primary service timelock is also included\n     * in struct.\n     *\n     * @param _chipId   The chip ID\n     * @return          Struct containing all records for each secondary service and primary service for the chip\n     */\n    function getAllChipServiceData(address _chipId) external view returns (ExpandedChipServices memory) {\n        bytes32 primaryService = chipServices[_chipId].primaryService;\n        bytes32[] memory secondaryServices = getChipSecondaryServices(_chipId);\n\n        uint256 servicesArrayLength = secondaryServices.length;\n        Service[] memory services = new Service[](servicesArrayLength);\n        for (uint256 i = 0; i < servicesArrayLength; ++i) {\n            bytes32 serviceId = secondaryServices[i];\n            Record[] memory records = getServiceContent(_chipId, serviceId);\n            services[i] = Service({\n                serviceId: serviceId,\n                records: records\n            });\n        }\n\n        return ExpandedChipServices({\n            primaryService: Service({\n                serviceId: primaryService,\n                records: getServiceContent(_chipId, primaryService)\n            }),\n            serviceTimelock: chipServices[_chipId].serviceTimelock,\n            secondaryServices: services\n        });\n    }\n\n    /**\n     * Get records for every secondary service and primary service for a chip. Primary service timelock is also included\n     * in struct.\n     *\n     * @param _chipId   The chip ID\n     * @return          List of ServiceRecords for the chip's primary service\n     */\n    function getPrimaryServiceContent(address _chipId) external view returns (Record[] memory) {\n        bytes32 primaryService = chipServices[_chipId].primaryService;\n        return getServiceContent(_chipId, primaryService);\n    }\n\n    /**\n     * Get list of secondary service Id's for a chip\n     *\n     * @param _chipId   The chip ID\n     * @return          List of secondary serviceIds for the chip\n     */\n    function getChipSecondaryServices(address _chipId) public view returns (bytes32[] memory) {\n        return chipServices[_chipId].secondaryServices;\n    }\n\n    /**\n     * @notice Checks if a service exists\n     *\n     * @param _serviceId        The service ID\n     * @return                  True if service exists, false otherwise\n     */\n    function isService(bytes32 _serviceId) public view returns (bool) {\n        return serviceInfo[_serviceId].owner != address(0);\n    }\n\n    /**\n     * \n     * @param _interfaceId The interface ID to check for\n     */\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(ERC165)\n        returns (bool)\n    {\n        return _interfaceId == type(IServicesRegistry).interfaceId ||\n        super.supportsInterface(_interfaceId);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Adds a new service record to an existing service. The service records must not contain duplicate record types or\n     * have an existing record of the same type.\n     *\n     * @param _serviceId        The service ID\n     * @param _record           ServiceRecord struct containing recordType, content, and appendId\n     */\n    function _addServiceRecord(bytes32 _serviceId, ServiceRecord calldata _record) internal {\n        // Case covers if record was previously added before function call or during function call\n        require(!serviceRecords[_serviceId][_record.recordType].enabled, \"Record type already exists for service\");\n\n        serviceRecords[_serviceId][_record.recordType] = RecordContent({\n            enabled: true,\n            content: _record.content,\n            appendId: _record.appendId\n        });\n\n        serviceInfo[_serviceId].recordTypes.push(_record.recordType);\n\n        emit ServiceRecordAdded(_serviceId, _record.recordType, _record.content, _record.appendId);\n    }\n\n    /**\n     * @notice Build a content string based on if the chipId should be appended to the base content\n     *\n     * @param _chipId           The chip ID\n     * @param _content          The base content\n     * @param _appendId         Whether or not to append the chipId to the content\n     * @return                  Bytestring representing the content\n     */\n    function _createContentString(address _chipId, bytes memory _content, bool _appendId) internal pure returns (bytes memory) {\n        // Must convert to string first then to bytes otherwise interpreters will try to convert address to a utf8 string\n        string memory stringChipId = Strings.toHexString(_chipId);\n        return _appendId ? bytes.concat(_content, bytes(stringChipId)) : _content;\n    }\n\n    function _validateSignatureAndExpiration(\n        bytes32 _digest,\n        address _chipId,\n        uint256 _commitBlock,\n        uint256 _maxBlockWindow,\n        bytes memory _signature\n    )\n        internal\n        view\n    {        \n        require(_chipId.isValidSignatureNow(_digest, _signature), \"Invalid signature\");\n\n        // Check that the signature was generated within the maxBlockWindow\n        require(block.number <= _commitBlock + _maxBlockWindow, \"Signature expired\");\n    }\n}\n"
    },
    "contracts/token/ERC721ReadOnly.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n/**\n * @notice An implementation of 721 that's publicly readonly (no approvals or transfers exposed).\n */\n\ncontract ERC721ReadOnly is ERC721 {\n    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}\n\n    function approve(address /*to*/, uint256 /*tokenId*/) public virtual override {\n        revert(\"ERC721 public approve not allowed\");\n    }\n\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n        return address(0);\n    }\n\n    function setApprovalForAll(address /*operator*/, bool /*approved*/) public virtual override {\n        revert(\"ERC721 public setApprovalForAll not allowed\");\n    }\n\n    function isApprovedForAll(address /*owner*/, address /*operator*/) public view virtual override returns (bool) {\n        return false;\n    }\n\n    function transferFrom(address /*from*/, address /*to*/, uint256 /*tokenId*/) public virtual override {\n        revert(\"ERC721 public transferFrom not allowed\");\n    }\n\n    function safeTransferFrom(address /*from*/, address /*to*/, uint256 /*tokenId*/) public virtual override {\n        revert(\"ERC721 public safeTransferFrom not allowed\");\n    }\n\n    function safeTransferFrom(address /*from*/, address /*to*/, uint256 /*tokenId*/, bytes memory /*data*/) public virtual override {\n        revert(\"ERC721 public safeTransferFrom not allowed\");\n    }\n}\n"
    },
    "contracts/token/IPBT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\n/**\n * @dev Contract for PBTs (Physical Backed Tokens).\n * NFTs that are backed by a physical asset, through a chip embedded in the physical asset.\n */\n\ninterface IPBT is IERC721Metadata {\n\n    function tokenIdFor(address chipAddress) external view returns (uint256);\n\n    function isChipSignatureForToken(uint256 tokenId, bytes calldata payload, bytes calldata signature)\n        external\n        view\n        returns (bool);\n\n    function transferTokenWithChip(\n        bytes calldata signatureFromChip,\n        uint256 blockNumberUsedInSig,\n        bool useSafeTransferFrom\n    )\n        external;\n\n    function transferToken(\n        address chipId,\n        bytes calldata signatureFromChip,\n        uint256 blockNumberUsedInSig,\n        bool useSafeTransferFrom,\n        bytes calldata payload\n    ) external;\n\n    /// @notice Emitted when a token is minted.\n    event PBTMint(uint256 indexed tokenId, address indexed chipAddress);\n\n    /// @notice Emitted when a token is mapped to a different chip.\n    /// Chip replacements may be useful in certain scenarios (e.g. chip defect).\n    event PBTChipRemapping(uint256 indexed tokenId, address indexed oldChipAddress, address indexed newChipAddress);\n}"
    },
    "contracts/token/IPBTSimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { IPBT } from \"./IPBT.sol\";\nimport { ITransferPolicy } from \"../interfaces/ITransferPolicy.sol\";\n\n/**\n * @dev Contract for PBTs (Physical Backed Tokens).\n * Modified PBT that allows for direct setting of owner and includes a transfer policy.\n */\n\ninterface IPBTSimple is IPBT {\n\n    function setOwner(\n        address _chipId,\n        address _newOwner,\n        uint256 _commitBlock,\n        bytes calldata _signature\n    ) \n        external;\n\n}\n"
    },
    "contracts/token/PBTSimple.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\nimport { ChipValidations } from \"../lib/ChipValidations.sol\";\nimport { ERC721ReadOnly } from \"./ERC721ReadOnly.sol\";\nimport { IPBT } from \"./IPBT.sol\";\nimport { ITransferPolicy } from \"../interfaces/ITransferPolicy.sol\";\n\n/**\n * @title PBTSimple\n * @author Arx\n *\n * @notice Implementation of PBT where tokenIds are assigned to chip addresses as the chips are added. The contract has a\n * transfer policy, which can be set by the chip owner and allows the owner to specify how the chip can be transferred to another party. \n * Additionally, chip owners can directly transfer their chips by calling setOwner, this function is only callable by the chip owner whereas \n * the transfer function is callable by anyone (assuming transfer policy conditions have been met).\n */\ncontract PBTSimple is IPBT, ERC721ReadOnly {\n    using SignatureChecker for address;\n    using ChipValidations for address;\n    using ECDSA for bytes;\n    using ECDSA for bytes32;\n    using Strings for uint256;\n\n    /* ============ Events ============ */\n\n    event TransferPolicyChanged(address transferPolicy);    // Emitted in setTransferPolicy\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyChipOwner(address _chipId) {\n        require(ownerOf(tokenIdFor(_chipId)) == msg.sender, \"Caller must be chip owner\");\n        _;\n    }\n\n    modifier onlyMintedChip(address _chipId) {\n        require(_exists(_chipId), \"Chip must be minted\");\n        _;\n    }\n    \n    /* ============ State Variables ============ */\n    string public baseURI;                                       // Base URI for the token\n    uint256 public immutable maxBlockWindow;                     // Amount of blocks from commitBlock after which chip signatures are expired\n    ITransferPolicy public transferPolicy;                       // Transfer policy for the PBT\n    mapping(address=>uint256) public chipIdToTokenId;            // Maps chipId to tokenId\n    mapping(uint256=>address) public tokenIdToChipId;            // Maps tokenId to chipId\n    /* ============ Constructor ============ */\n\n    /**\n     * @dev Constructor for ClaimedPBT. Sets the name and symbol for the token.\n     *\n     * @param _name             The name of the token\n     * @param _symbol           The symbol of the token\n     * @param _maxBlockWindow   The maximum amount of blocks a signature used for updating chip table is valid for\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _baseTokenURI,\n        uint256 _maxBlockWindow,\n        ITransferPolicy _transferPolicy\n    )\n        ERC721ReadOnly(_name, _symbol)\n    {\n        // _baseURI is inherited from ERC721Metadata\n        baseURI = _baseTokenURI;\n        maxBlockWindow = _maxBlockWindow;\n        transferPolicy = _transferPolicy;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice Included for compliance with EIP-5791 standard but left unimplemented to ensure transfer policies can't be ignored.\n     */\n    function transferTokenWithChip(\n        bytes calldata /*signatureFromChip*/,\n        uint256 /*blockNumberUsedInSig*/,\n        bool /*useSafeTransfer*/\n    )\n        public\n        virtual\n    {\n        revert(\"Not implemented\");\n    }\n\n    /**\n     * @notice Allow a user to transfer a chip to a new owner with additional checks. A transfer policy must be set in order for\n     * transfer to go through. The data contained in _payload will be dependent on the implementation of the transfer policy, however\n     * the signature should be signed by the chip. EIP-1271 compatibility should be implemented in the chip's TransferPolicy contract.\n     *\n     * @param chipId                Chip ID (address) of chip being transferred\n     * @param signatureFromChip     Signature of keccak256(msg.sender, blockhash(blockNumberUsedInSig), _payload) signed by chip\n     *                              being transferred\n     * @param blockNumberUsedInSig  Block number used in signature\n     * @param useSafeTransfer       Indicates whether to use safeTransferFrom or transferFrom\n     * @param payload               Encoded payload containing data required to execute transfer. Data structure will be dependent\n     *                              on implementation of TransferPolicy\n     */\n    function transferToken(\n        address chipId,\n        bytes calldata signatureFromChip,\n        uint256 blockNumberUsedInSig,\n        bool useSafeTransfer,\n        bytes calldata payload\n    ) \n        public\n        virtual\n        onlyMintedChip(chipId)\n    {\n        // ChipInfo memory chipInfo = chipTable[chipId];\n        address chipOwner = ownerOf(tokenIdFor(chipId));\n\n        // Check that the signature is valid, create own scope to prevent stack-too-deep error\n        {\n            bytes32 signedHash = _createSignedHash(blockNumberUsedInSig, payload);\n            require(chipId.isValidSignatureNow(signedHash, signatureFromChip), \"Invalid signature\");\n        }\n\n        _transferPBT(chipOwner, tokenIdFor(chipId), useSafeTransfer);\n\n        // Validation of the payload beyond ensuring it was signed by the chip is left up to the TransferPolicy contract.\n        //authorizeTransfer(address _chipId, address _sender, address _chipOwner, bytes _payload, bytes _signature)\n        transferPolicy.authorizeTransfer(\n            chipId,\n            msg.sender,\n            chipOwner,\n            payload,\n            signatureFromChip\n        );\n    }\n\n    /**\n     * @dev ONLY CHIP OWNER: Sets the owner for a chip. Chip owner must submit transaction along with\n     * a signature from the chipId commiting to a block the signature was generated. This is to prevent any\n     * replay attacks. If the transaction isn't submitted within the MAX_BLOCK_WINDOW from the commited block\n     * this function will revert.\n     *\n     * @param _chipId           The chipId to set the owner for\n     * @param _newOwner         The address of the new chip owner\n     * @param _commitBlock      The block the signature is tied to (used to put a time limit on the signature)\n     * @param _signature        The signature generated by the chipId (should just be a signature of the commitBlock)\n     */\n    function setOwner(\n        address _chipId,\n        address _newOwner,\n        uint256 _commitBlock,\n        bytes calldata _signature\n    )\n        public\n        virtual\n        onlyChipOwner(_chipId)\n    {\n        // Check that the signature is valid for the payload\n        _chipId.validateSignatureAndExpiration(\n            _commitBlock,\n            maxBlockWindow,\n            abi.encodePacked(_commitBlock, _newOwner),  // Formulate the payload\n            _signature\n        );\n\n        // Set the new owner\n        _transfer(msg.sender, _newOwner, tokenIdFor(_chipId));\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     * @dev Using OpenZeppelin's SignatureChecker library, checks if the signature is valid for the payload. Library is\n     * ERC-1271 compatible, so it will check if the chipId is a contract and if so, if it implements the isValidSignature.\n     *\n     * @param _tokenId      The tokenId to check the signature for\n     * @param _payload      The payload to check the signature for\n     * @param _signature    The signature to check\n     * @return bool         If the signature is valid, false otherwise\n     */\n    function isChipSignatureForToken(uint256 _tokenId, bytes calldata _payload, bytes calldata _signature)\n        public\n        view\n        returns (bool)\n    {\n        bytes32 _payloadHash = abi.encodePacked(_payload).toEthSignedMessageHash();\n        address _chipId = tokenIdToChipId[_tokenId];\n        return _chipId.isValidSignatureNow(_payloadHash, _signature);\n    }\n\n    /**\n     * @dev Returns the tokenURI for a given chipId. Chip must have been claimed / token minted.\n     *\n     * @param _chipId      The tokenId to get the tokenURI for\n     * @return string       The tokenURI for the given tokenId\n     */\n    function tokenURI(address _chipId) public view virtual onlyMintedChip(_chipId) returns (string memory) {\n        uint256 _tokenId = tokenIdFor(_chipId);\n        return tokenURI(_tokenId);\n    }\n\n    /**\n     * @dev Returns the tokenId for a given chipId\n     *\n     * @param _chipId       The chipId to get the tokenId for\n     * @return tokenId      The tokenId for the given chipId\n     */\n    function tokenIdFor(address _chipId) public view returns (uint256 tokenId) {\n        require(chipIdToTokenId[_chipId] != 0, \"Chip must be minted\");\n        return chipIdToTokenId[_chipId];\n    }\n\n    /**\n     * \n     * @param _interfaceId The interface ID to check for\n     */\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(ERC721, IERC165)\n        returns (bool)\n    {\n        return _interfaceId == type(IPBT).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @dev Returns the base URI for the token. This is used to generate the tokenURI for a given tokenId.\n     *\n     * @return string       The base URI for the token\n     */\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n\n    /**\n     * @dev Sets the transfer policy for PBTSimple.\n     * @param _newPolicy    The address of the new transfer policy. We allow the zero address in case owner doesn't want to allow xfers.\n     */\n    function _setTransferPolicy(\n        ITransferPolicy _newPolicy\n    )\n        internal\n        virtual\n    {\n        require(address(_newPolicy) != address(0), \"Transfer policy cannot be zero address\");\n\n        // Set the transfer policy\n        transferPolicy = _newPolicy;\n\n        emit TransferPolicyChanged(address(_newPolicy));\n    }\n\n    /**\n     * @dev Mints a new token and assigns it to the given address. Also adds the chipId to the tokenIdToChipId mapping,\n     * adds the ChipInfo to the chipTable, and increments the tokenIdCounter.\n     *\n     * @param _to           The address to mint the token to\n     * @param _chipId       The chipId to mint the token for\n     * @return uint256      The tokenId of the newly minted token\n     */\n    function _mint(\n        address _to,\n        address _chipId,\n        bytes32 _ersNode\n    )\n        internal\n        virtual\n        returns(uint256)\n    {\n        uint256 tokenId = uint256(_ersNode);\n        _mint(_to, tokenId);\n\n        chipIdToTokenId[_chipId] = tokenId;\n        tokenIdToChipId[tokenId] = _chipId;\n\n        emit PBTMint(tokenId, _chipId);\n        return tokenId;\n    }\n\n    function _createSignedHash(\n        uint256 _blockNumberUsedInSig,\n        bytes memory _customPayload\n    )\n        internal\n        virtual\n        returns (bytes32)\n    {\n        // The blockNumberUsedInSig must be in a previous block because the blockhash of the current\n        // block does not exist yet.\n        require(block.number >= _blockNumberUsedInSig, \"Block number must have been mined\");\n        require(block.number - _blockNumberUsedInSig <= maxBlockWindow, \"Block number must be within maxBlockWindow\");\n\n        return abi.encodePacked(msg.sender, blockhash(_blockNumberUsedInSig), _customPayload).toEthSignedMessageHash();\n    }\n\n    /**\n     * @notice Handle transfer of PBT inclusing whether to transfer using safeTransfer. The _to address is always the msg.sender.\n     *\n     * @param _from                 Address of owner transferring PBT\n     * @param _tokenId              ID of PBT being transferred\n     * @param _useSafeTransfer      Indicates whether to use safeTransferFrom or transferFrom\n     */\n    function _transferPBT(address _from, uint256 _tokenId, bool _useSafeTransfer) internal {\n        if (_useSafeTransfer) {\n            _safeTransfer(_from, msg.sender, _tokenId, \"\");\n        } else {\n            _transfer(_from, msg.sender, _tokenId);\n        }\n    }\n\n    /**\n     * @dev Indicates whether the chipId has been claimed or not\n     *\n     * @param _chipId       The chipId to check\n     * @return bool         True if the chipId has been claimed, false otherwise\n     */\n    function _exists(address _chipId) internal view returns (bool) {\n        // TODO: review this logic closely; ERC721.sol will revert if the tokenId doen't exist\n        return chipIdToTokenId[_chipId] != 0;\n    }\n}\n"
    },
    "contracts/token/transfer-policies/OpenTransferPolicy.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport { ITransferPolicy } from \"../../interfaces/ITransferPolicy.sol\";\n\n/**\n * @title OpenTransferPolicy\n * @dev This transfer policy performs no checks and creates parity with the PBT standard\n * transferTokenWithChip function. TransferPolicy is necessary because the ChipRegistry does\n * not support transferTokenWithChip so that transferToken cannot be overridden.\n */\ncontract OpenTransferPolicy is ITransferPolicy {\n\n    /* ============ Constructor ============ */\n\n    constructor() {}\n    \n    /* ============ External Functions ============ */\n    /**\n      * @notice This function enforces no additional checks and allows the transfer to proceed\n      * for parity with transferTokenWithChip function in PBT standard.\n      */\n    function authorizeTransfer(\n        address /*_chipId*/,\n        address /*_sender*/,\n        address /*_chipOwner*/,\n        bytes calldata /*_payload*/,\n        bytes calldata /*_signature*/\n    )\n        external\n        override\n    {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}