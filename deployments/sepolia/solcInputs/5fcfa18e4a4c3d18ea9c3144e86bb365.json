{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/ArxProjectEnrollmentManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\nimport { IChipRegistry } from \"./interfaces/IChipRegistry.sol\";\nimport { IERS } from \"./interfaces/IERS.sol\";\nimport { IManufacturerRegistry } from \"./interfaces/IManufacturerRegistry.sol\";\nimport { IProjectRegistrar } from \"./interfaces/IProjectRegistrar.sol\";\nimport { ITransferPolicy } from \"./interfaces/ITransferPolicy.sol\";\nimport { IDeveloperRegistrar } from \"./interfaces/IDeveloperRegistrar.sol\";\nimport { AuthenticityProjectRegistrar } from \"./project-registrars/AuthenticityProjectRegistrar.sol\";\n\n/**\n * @title ArxProjectEnrollmentManager\n * @author Arx\n * \n * @notice Smart contract that handles deployment of new Project Registrar contracts for new Developer projects.\n * This should be set as the owner of the Developer Registrar contract before adding any new projects.\n */\ncontract ArxProjectEnrollmentManager is Ownable {\n    \n    using ECDSA for bytes;\n    using SignatureChecker for address;\n\n    /* ============ Events ============ */\n    event ProjectRegistrarDeployed(address indexed projectRegistrar, address indexed owner);\n    event NewTransferPolicySet(ITransferPolicy indexed transferPolicy);\n    event NewMaxBlockWindowSet(uint256 maxBlockWindow);\n\n    /* ============ State Variables ============ */\n    IChipRegistry public immutable chipRegistry;\n    IDeveloperRegistrar public immutable developerRegistrar;\n    IERS public immutable ers;\n    IManufacturerRegistry public immutable manufacturerRegistry;\n    ITransferPolicy public transferPolicy;\n    uint256 public maxBlockWindow;\n    \n    /* ============ Constructor ============ */\n    /**\n     * @param _chipRegistry             The Chip Registry contract of the ERS system\n     * @param _developerRegistrar       The Developer Registrar contract of the ERS system\n     * @param _ers                      The ERS Registry contract of the ERS system\n     * @param _manufacturerRegistry     The Manufacturer Registry contract of the ERS system\n     * @param _transferPolicy           The transfer policy contract for the project being deployed\n     * @param _maxBlockWindow           The maximum amount of blocks a signature used for updating chip table is valid for\n     *                                  passed to all ProjectRegistrar contracts deployed by this contract\n     */\n    constructor(\n        IChipRegistry _chipRegistry, \n        IDeveloperRegistrar _developerRegistrar, \n        IERS _ers,\n        IManufacturerRegistry _manufacturerRegistry,\n        ITransferPolicy _transferPolicy,\n        uint256 _maxBlockWindow\n    )\n        Ownable()\n    {\n        transferPolicy = _transferPolicy;\n        chipRegistry = _chipRegistry;\n        developerRegistrar = _developerRegistrar;\n        manufacturerRegistry = _manufacturerRegistry;\n        ers = _ers;\n        maxBlockWindow = _maxBlockWindow;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n      * @notice Adds a new Developer's project to the ERS system by deploying the ProjectRegistrar contract via CREATE2 and\n      * registering it to the Developer Registrar. We use CREATE2 because we need the projectManager to provide proof of\n      * ownership by signing a hash of the projectRegistrar address with the projectPublicKey. This is not possible\n      * unless we know the address ahead of time, hence we use CREATE2 which allows us to know the address.\n      * \n      * @param _projectManager          The address that will be set as the owner of the project registrar contract\n      * @param _projectClaimDataUri     URI pointing to location of off-chain data required to claim chips\n      * @param _nameHash                Keccak256 hash of the human-readable name for the chip being claimed\n      * @param _merkleRoot              Merkle root of the Developer Merkle Tree made up of the chips enrolled to this project\n      * @param _projectPublicKey        Public key used in the generation of the Developer certificates\n      * @param _developerMerkleInfo     The Developer Merkle Info of the proving chip\n      * @param _manufacturerValidation  Manufacturer Validation info for the proving chip\n      * @param _chipOwnershipProof      The chip signature of the hash of the chainId and msg.sender\n      * @param _projectOwnershipProof   Signed hash of the _projectRegistrar address by the _projectPublicKey\n      */\n    function addProject(\n        address _projectManager,\n        string memory _projectClaimDataUri,\n        bytes32 _nameHash,\n        bytes32 _merkleRoot,\n        address _projectPublicKey,\n        address _provingChip,\n        IChipRegistry.DeveloperMerkleInfo memory _developerMerkleInfo,\n        IChipRegistry.ManufacturerValidation memory _manufacturerValidation,\n        bytes memory _chipOwnershipProof,\n        bytes memory _projectOwnershipProof\n    )\n        public \n    {\n        require(_isNotZeroAddress(_projectManager), \"Invalid project manager address\");\n        require(_isNotZeroAddress(_projectPublicKey), \"Invalid project public key address\");\n\n        _validateOwnershipAndTreeInclusion(\n            _provingChip,\n            _chipOwnershipProof,\n            _merkleRoot,\n            _developerMerkleInfo,\n            _manufacturerValidation\n        );\n\n        _deployProjectRegistrarAndAddProject(\n            _projectManager,\n            _merkleRoot,\n            _nameHash,\n            _projectPublicKey,\n            _projectOwnershipProof,\n            _projectClaimDataUri\n        );\n    }\n\n    /**\n     * @notice Sets the transfer policy for all projects deployed by this contract\n     * \n     * @param _transferPolicy   The new transfer policy contract\n     */\n    function setTransferPolicy(ITransferPolicy _transferPolicy) external onlyOwner {\n        transferPolicy = _transferPolicy;\n        emit NewTransferPolicySet(_transferPolicy);\n    }\n\n    /**\n     * @notice Sets the max block window for all projects deployed by this contract. Max block window used to\n     * validate ownership signatures for chip claims made through ProjectRegistrar.\n     * \n     * @param _maxBlockWindow   The new max block window\n     */\n    function setMaxBlockWindow(uint256 _maxBlockWindow) external onlyOwner {\n        maxBlockWindow = _maxBlockWindow;\n        emit NewMaxBlockWindowSet(_maxBlockWindow);\n    }\n    \n    /* ============ Internal Functions ============ */\n    /**\n     * @dev Returns true if passed address is not the zero address\n     * \n     * @param _address The address to check\n     */\n    function _isNotZeroAddress(address _address) internal pure returns(bool){\n        return _address != address(0);\n    }\n\n    /**\n     * @dev Validates that the chip used as proof of ownership is in possesion of the msg.sender, is included in the project merkle root, AND\n     * is a chip that's been enrolled in the ManufacturerRegistry.\n     *\n     * @param _provingChip                  The chip used as proof of ownership\n     * @param _chipOwnershipProof           The signature of the chip owner over the hash of the chainId and msg.sender\n     * @param _merkleRoot                   The merkle root of the project\n     * @param _developerMerkleInfo          The Developer Merkle Info of the proving chip\n     * @param _manufacturerValidation       Manufacturer Validation info for the proving chip\n     */\n    function _validateOwnershipAndTreeInclusion(\n        address _provingChip,\n        bytes memory _chipOwnershipProof,\n        bytes32 _merkleRoot,\n        IChipRegistry.DeveloperMerkleInfo memory _developerMerkleInfo,\n        IChipRegistry.ManufacturerValidation memory _manufacturerValidation\n    )\n        internal\n        view\n    {\n        // Validate chip ownership\n        bytes32 msgHash = abi.encodePacked(block.chainid, msg.sender).toEthSignedMessageHash();\n        require(_provingChip.isValidSignatureNow(msgHash, _chipOwnershipProof), \"Invalid chip ownership proof\");\n\n        // Validate chip is included in merkle tree\n        bytes32 node = keccak256(\n            bytes.concat(keccak256(\n                abi.encode(\n                    _developerMerkleInfo.developerIndex,\n                    _provingChip,\n                    _manufacturerValidation.enrollmentId,\n                    _developerMerkleInfo.lockinPeriod,\n                    _developerMerkleInfo.serviceId,\n                    _developerMerkleInfo.tokenUri\n                )\n            ))\n        );\n\n        require(MerkleProof.verify(_developerMerkleInfo.developerProof, _merkleRoot, node), \"Invalid chip tree inclusion proof\");\n\n        // Validate that the chip is part of a valid manufacturer enrollment\n        bool isEnrolledChip = manufacturerRegistry.isEnrolledChip(\n            _manufacturerValidation.enrollmentId,\n            _manufacturerValidation.mIndex,\n            _provingChip,\n            _manufacturerValidation.manufacturerProof\n        );\n        require(isEnrolledChip, \"Chip not enrolled with ManufacturerRegistry\");\n    }\n\n\n    /**\n     * @dev Deploys a new ProjectRegistrar contract via CREATE2 and registers it to the Developer Registrar\n     * \n     * @param _projectManager          The address that will be set as the owner of the project registrar contract\n     * @param _merkleRoot              Merkle root of the Developer Merkle Tree made up of the chips enrolled to this project\n     * @param _nameHash                Keccak256 hash of the human-readable name for the chip being claimed\n     * @param _projectPublicKey        Public key used in the generation of the Developer certificates\n     * @param _projectOwnershipProof   Signed hash of the _projectRegistrar address by the _projectPublicKey\n     * @param _projectClaimDataUri     URI pointing to location of off-chain data required to claim chips\n     */\n    function _deployProjectRegistrarAndAddProject(\n        address _projectManager,\n        bytes32 _merkleRoot,\n        bytes32 _nameHash,\n        address _projectPublicKey,\n        bytes memory _projectOwnershipProof,\n        string memory _projectClaimDataUri\n    )\n        internal\n    {\n        // Deploy new AuthenticityProjectRegistrar with Create2\n        AuthenticityProjectRegistrar newProjectRegistrar = new AuthenticityProjectRegistrar{salt: _merkleRoot}(\n            _projectManager, \n            chipRegistry, \n            ers, \n            developerRegistrar, \n            maxBlockWindow\n        );\n\n        // Register new Project Registrar to Developer Registrar\n        developerRegistrar.addProject(\n            _nameHash, \n            newProjectRegistrar, \n            _merkleRoot, \n            _projectPublicKey, \n            transferPolicy, \n            _projectOwnershipProof,\n            _projectClaimDataUri\n        );\n\n        emit ProjectRegistrarDeployed(address(newProjectRegistrar), msg.sender);\n    }\n}\n\n"
    },
    "contracts/auth-models/SECP256k1Model.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/**\n * @title SECP256k1Model\n * @author Arx\n *\n * @notice Auth model contract that encodes an implementation of the curve used to sign chip messages. These\n * contracts are referred to by Manufacturer's when they enroll chips in the ManufacturerRegistry so that chip\n * holders know the curve used to sign messages from the chip. Chip holders can validate chip signatures against\n * this contract using the `verify` function. This auth model specifically uses the SECP256k1 curve native to\n * Ethereum.\n */\ncontract SECP256k1Model {\n    using ECDSA for bytes32;\n\n    /**\n     * @notice Verifies a signature against a message and signer address\n     * @param _message      The message that was signed\n     * @param _signature    The signature to verify\n     * @param _signer       The address that signed the message\n     * @return bool         True if the signature is valid, false otherwise\n     */\n    function verify(\n        bytes32 _message,\n        bytes memory _signature,\n        address _signer\n    ) public pure returns (bool) {\n        return _message.recover(_signature) == _signer;\n    }\n}\n"
    },
    "contracts/ChipRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\nimport { ClaimedPBT } from \"./token/ClaimedPBT.sol\";\nimport { IChipRegistry } from \"./interfaces/IChipRegistry.sol\";\nimport { IERS } from \"./interfaces/IERS.sol\";\nimport { IManufacturerRegistry } from \"./interfaces/IManufacturerRegistry.sol\";\nimport { IPBT } from \"./token/IPBT.sol\";\nimport { IProjectRegistrar } from \"./interfaces/IProjectRegistrar.sol\";\nimport { IServicesRegistry } from \"./interfaces/IServicesRegistry.sol\";\nimport { ITransferPolicy } from \"./interfaces/ITransferPolicy.sol\";\nimport { IDeveloperRegistry } from \"./interfaces/IDeveloperRegistry.sol\";\nimport { StringArrayUtils } from \"./lib/StringArrayUtils.sol\";\n\n/**\n * @title ChipRegistry\n * @author Arx\n *\n * @notice Entrypoint for resolving chips added to Arx Protocol. Developers can enroll new projects into this registry by specifying a\n * ProjectRegistrar to manage chip claims. Chip claims are forwarded from ProjectRegistrars at which point a ERC-721\n * compliant \"token\" of the chip is minted to the claimant and other metadata associated with the chip is set. Any project\n * looking to integrate ERS chips should get resolution information about chips from this address. Because chips are\n * represented as tokens any physical chip transfers should also be completed on-chain in order to get full functionality\n * for the chip.\n */\ncontract ChipRegistry is IChipRegistry, ClaimedPBT, Ownable {\n\n    using SignatureChecker for address;\n    using ECDSA for bytes;\n    using StringArrayUtils for string[];\n\n    /* ============ Errors ============ */\n    error OffchainLookup(address sender, string[] urls, bytes callData, bytes4 callbackFunction, bytes extraData);\n\n    /* ============ Events ============ */\n\n    event ProjectEnrollmentAdded(                   // Emitted during addProjectEnrollment\n        address indexed developerRegistrar,\n        address indexed projectRegistrar,\n        address indexed transferPolicy,\n        address projectPublicKey,\n        bytes32 merkleRoot,\n        string projectClaimDataUri\n    );\n\n    event ProjectMerkleRootUpdated(                 // Emitted during updateProjectMerkleRoot\n        address indexed projectRegistrar,\n        bytes32 merkleRoot,\n        string projectClaimDataUri\n    );\n\n    event ChipClaimed(                              // Emitted during claimChip\n        address indexed chipId,\n        uint256 tokenId,\n        address indexed owner,\n        bytes32 serviceId,\n        bytes32 ersNode,\n        bytes32 indexed enrollmentId,\n        string tokenUri\n    );\n\n    event GatewayURLAdded(string gatewayUrl);               // Emitted during addGatewayURL\n    event GatewayURLRemoved(string gatewayUrl);             // Emitted during removeGatewayURL\n    event MaxLockinPeriodUpdated(uint256 maxLockinPeriod);  // Emitted during updateMaxLockinPeriod\n    event RegistryInitialized(                              // Emitted during initialize\n        address ers,\n        address servicesRegistry,\n        address developerRegistry\n    );\n\n    /* ============ Structs ============ */\n\n    struct ProjectInfo {\n        bytes32 merkleRoot;\n        address projectPublicKey;\n        ITransferPolicy transferPolicy;\n        uint256 creationTimestamp;\n        bool claimsStarted;\n        string projectClaimDataUri;\n    }\n    \n    /* ============ Constants ============ */\n    bytes32 public constant URI_RECORDTYPE = bytes32(\"tokenUri\");\n    bytes32 public constant REDIRECT_URL_RECORDTYPE = bytes32(\"redirectUrl\");\n    \n    /* ============ State Variables ============ */\n    IManufacturerRegistry public immutable manufacturerRegistry;\n    IERS public ers;\n    IServicesRegistry public servicesRegistry;\n    IDeveloperRegistry public developerRegistry;\n    bool public initialized;\n\n    mapping(IProjectRegistrar=>ProjectInfo) public projectEnrollments;  // Maps ProjectRegistrar addresses to ProjectInfo\n    string[] internal gatewayUrls;                                      // Array of gateway URLs for resolving unclaimed chips using EIP-3668\n    uint256 public maxLockinPeriod;                                     // Max amount of time chips can be locked into a service after a\n                                                                        // project's creation timestamp\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructor for ChipRegistry\n     *\n     * @param _manufacturerRegistry     Address of the ManufacturerRegistry contract\n     * @param _gatewayUrls              Array of gateway URLs for resolving unclaimed chips using EIP-3668\n     * @param _maxBlockWindow           The maximum amount of blocks a signature used for updating chip table is valid for\n     * @param _maxLockinPeriod          The maximum amount of time a chip can be locked into a service for beyond the project's creation timestamp\n    */\n    constructor(\n        IManufacturerRegistry _manufacturerRegistry,\n        string[] memory _gatewayUrls,\n        uint256 _maxBlockWindow,\n        uint256 _maxLockinPeriod\n    )\n        ClaimedPBT(\"ERS\", \"ERS\", _maxBlockWindow)\n        Ownable()\n    {\n        manufacturerRegistry = _manufacturerRegistry;\n        gatewayUrls = _gatewayUrls;\n        maxLockinPeriod = _maxLockinPeriod;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @dev ONLY Developer REGISTRAR: Enroll new project in ChipRegistry. This function is only callable by DeveloperRegistrars. In order to use\n     * this function the project must first sign a message of the _projectRegistrar address with the _projectPublicKey's matching\n     * private key. This key MUST be the same key used to sign all the chip certificates for the project. This creates a link between\n     * chip certificates (which may be posted online) and the deployer of the registrar hence making sure that no malicious Developer is able\n     * to steal another Developer's chips for their own enrollment (unless the private key happens to be leaked). This function will\n     * revert if the project is already enrolled. See documentation for more instructions on how to create a project merkle root.\n     *\n     * @param _projectRegistrar          Address of the ProjectRegistrar contract\n     * @param _projectPublicKey          Public key of the project (used to sign chip certificates and create _signature)\n     * @param _transferPolicy            Address of the transfer policy contract governing chip transfers\n     * @param _merkleRoot                Merkle root of the project's chip claims\n     * @param _projectOwnershipProof     Signature of the _projectRegistrar address signed by the _projectPublicKey. Proves ownership over the\n     *                                   key that signed the chip custodyProofs and developerInclusionProofs   \n     * @param _projectClaimDataUri       URI pointing to location of off-chain data required to claim chips\n     */\n    function addProjectEnrollment(\n        IProjectRegistrar _projectRegistrar,\n        address _projectPublicKey,\n        ITransferPolicy _transferPolicy,\n        bytes32 _merkleRoot,\n        bytes calldata _projectOwnershipProof,\n        string calldata _projectClaimDataUri\n    )\n        external\n    {\n        require(developerRegistry.isDeveloperRegistrar(msg.sender), \"Must be Developer Registrar\");\n        require(projectEnrollments[_projectRegistrar].projectPublicKey == address(0), \"Project already enrolled\");\n        // When enrolling a project, public key cannot be zero address so we can use as check to make sure calling address is associated\n        // with a project enrollment during claim\n        require(_projectPublicKey != address(0), \"Invalid project public key\");\n\n        // .toEthSignedMessageHash() prepends the message with \"\\x19Ethereum Signed Message:\\n\" + message.length and hashes message\n        bytes32 messageHash = abi.encodePacked(block.chainid, _projectRegistrar).toEthSignedMessageHash();\n        require(_projectPublicKey.isValidSignatureNow(messageHash, _projectOwnershipProof), \"Invalid signature\");\n\n        projectEnrollments[_projectRegistrar] = ProjectInfo({\n            merkleRoot: _merkleRoot,\n            projectPublicKey: _projectPublicKey,\n            transferPolicy: _transferPolicy,\n            projectClaimDataUri: _projectClaimDataUri,\n            creationTimestamp: block.timestamp,\n            claimsStarted: false\n        });\n\n        emit ProjectEnrollmentAdded(\n            msg.sender,\n            address(_projectRegistrar),\n            _projectPublicKey,\n            address(_transferPolicy),\n            _merkleRoot,\n            _projectClaimDataUri\n        );\n    }\n\n    /**\n     * @dev Update the merkle root of a project enrollment. This function is only callable by the project's public key. This function\n     * will revert if the project has already claimed a chip from this enrollment or the 7-day update time period has elapsed. New URI\n     * is required because IPFS records are immutable so changing the merkle root would require a new IPFS record.\n     *\n     * @param _projectRegistrar          Address of the ProjectRegistrar contract\n     * @param _merkleRoot                Merkle root of the project's chip claims\n     * @param _projectClaimDataUri       URI pointing to location of off-chain data required to claim chips\n     */\n    function updateProjectMerkleRoot(\n        IProjectRegistrar _projectRegistrar,\n        bytes32 _merkleRoot,\n        string calldata _projectClaimDataUri\n    )\n        external\n    {\n        require(msg.sender == projectEnrollments[_projectRegistrar].projectPublicKey, \"Caller must be project public key\");\n        require(projectEnrollments[_projectRegistrar].creationTimestamp + 30 days > block.timestamp, \"Update period has elapsed\");\n        require(!projectEnrollments[_projectRegistrar].claimsStarted, \"Claims have already started\");\n\n        projectEnrollments[_projectRegistrar].merkleRoot = _merkleRoot;\n        projectEnrollments[_projectRegistrar].projectClaimDataUri = _projectClaimDataUri;\n        \n        emit ProjectMerkleRootUpdated(address(_projectRegistrar), _merkleRoot, _projectClaimDataUri);\n    }\n\n    /**\n     * @notice Allow a user to claim a chip from a project enrollment. Enrollment allows the chip to resolve to the project's preferred\n     * service. Additionally, claiming creates a Physically-Bound Token representation of the chip.\n     *\n     * @dev This function will revert if the chip has already been claimed, if invalid certificate data is provided or if the chip is\n     * not part of the project enrollment (not in the project merkle root). Addtionally, there are checks to ensure that the calling\n     * ProjectRegistrar has implemented the correct ERS logic. This function is EIP-1271 compatible and can be used to verify chip\n     * claims tied to an account contract.\n     *\n     * @param _chipId                       Chip ID (address)\n     * @param _chipClaim                    Struct containing information for validating merkle proof, chip owner, and chip's ERS node\n     * @param _manufacturerValidation       Struct containing information for chip's inclusion in manufacturer's merkle tree\n     * @param _developerInclusionProof      Signature of the chipId signed by the project's public key\n     * @param _developerCustodyProof        Signature of the projectPublicKey signed by the chip's private key\n     */\n    function claimChip(\n        address _chipId,\n        ChipClaim calldata _chipClaim,\n        ManufacturerValidation memory _manufacturerValidation,\n        bytes memory _developerInclusionProof,\n        bytes memory _developerCustodyProof\n    )\n        external virtual\n    {\n        ProjectInfo memory projectInfo = projectEnrollments[IProjectRegistrar(msg.sender)];\n\n        require(chipTable[_chipId].tokenId == 0, \"Chip already claimed\");\n        require(_chipClaim.owner != address(0), \"Invalid chip owner\");\n        require(projectInfo.projectPublicKey != address(0), \"Project not enrolled\");\n        \n        // Validate that chip state has been set correctly in ERS\n        require(ers.isValidChipState(_chipClaim.ersNode, _chipId, _chipClaim.owner), \"Inconsistent state in ERS\");\n\n        _validateCertificates(_chipId, projectInfo.projectPublicKey, _developerInclusionProof, _developerCustodyProof);\n\n        // Validate merkle proofs verifying enrollment in project and project using manufacturer chips\n        _validateDeveloperMerkleProof(\n            _chipId,\n            _chipClaim.developerMerkleInfo,\n            _manufacturerValidation.enrollmentId,\n            projectInfo.merkleRoot\n        );\n        _validateManufacturerMerkleProof(_chipId, _manufacturerValidation);\n\n        // Lockin Period is min of the lockinPeriod specified by the Developer and the max time period specified by governance\n        uint256 lockinPeriod = projectInfo.creationTimestamp + maxLockinPeriod > _chipClaim.developerMerkleInfo.lockinPeriod ?\n            _chipClaim.developerMerkleInfo.lockinPeriod :\n            projectInfo.creationTimestamp + maxLockinPeriod;\n        \n        // Set primaryService on ServicesRegistry\n        servicesRegistry.setInitialService(\n            _chipId,\n            _chipClaim.developerMerkleInfo.serviceId,\n            lockinPeriod\n        );\n\n        ChipInfo memory chipInfo = ChipInfo({\n            tokenId: 0,     // temporary value, will be set in _mint\n            transferPolicy: projectInfo.transferPolicy,\n            tokenUri: _chipClaim.developerMerkleInfo.tokenUri,\n            tokenData: _encodeTokenData(_chipClaim.ersNode, _manufacturerValidation.enrollmentId)\n        });\n        // Mint a PBT this function fills out the ownership mapping, maps tokenId to chipId, fills out\n        // the chip table and increments the tokenIdCounter\n        uint256 tokenId = ClaimedPBT._mint(_chipClaim.owner, _chipId, chipInfo);\n\n        if (!projectInfo.claimsStarted) {\n            projectEnrollments[IProjectRegistrar(msg.sender)].claimsStarted = true;\n        }\n\n        emit ChipClaimed(\n            _chipId,\n            tokenId,\n            _chipClaim.owner,\n            _chipClaim.developerMerkleInfo.serviceId,\n            _chipClaim.ersNode,\n            _manufacturerValidation.enrollmentId,\n            _chipClaim.developerMerkleInfo.tokenUri\n        );\n    }\n\n    /**\n     * @notice Included for compliance with EIP-5791 standard but left unimplemented to ensure transfer policies can't be ignored.\n     */\n    function transferTokenWithChip(\n        bytes calldata /*signatureFromChip*/,\n        uint256 /*blockNumberUsedInSig*/,\n        bool /*useSafeTransfer*/\n    )\n        public\n        virtual\n        override(ClaimedPBT, IPBT)\n    {\n        revert(\"Not implemented\");\n    }\n\n    /**\n     * @notice Allow a user to transfer a chip to a new owner, new owner must submit transaction. Use ClaimedPBT logic which calls\n     * TransferPolicy to execute the transfer of the PBT and chip. Update chip's ERS node in order to keep data consistency. EIP-1271\n     * compatibility should be implemented in the chip's TransferPolicy contract.\n     *\n     * @param chipId                Chip ID (address) of chip being transferred\n     * @param signatureFromChip     Signature of keccak256(msg.sender, blockhash(blockNumberUsedInSig), _payload) signed by chip\n     *                              being transferred\n     * @param blockNumberUsedInSig  Block number used in signature\n     * @param useSafeTransferFrom   Indicates whether to use safeTransferFrom or transferFrom\n     * @param payload               Encoded payload containing data required to execute transfer. Data structure will be dependent\n     *                              on implementation of TransferPolicy\n     */\n    function transferToken(\n        address chipId,\n        bytes calldata signatureFromChip,\n        uint256 blockNumberUsedInSig,\n        bool useSafeTransferFrom,\n        bytes calldata payload\n    ) \n        public\n        override(ClaimedPBT, IPBT)\n    {\n        // Validations happen in ClaimedPBT / TransferPolicy\n        ClaimedPBT.transferToken(chipId,  signatureFromChip, blockNumberUsedInSig, useSafeTransferFrom, payload);\n        _setERSOwnerForChip(chipId, msg.sender);\n    }\n\n    /**\n     * @dev ONLY CHIP OWNER (enforced in ClaimedPBT): Sets the owner for a chip. Chip owner must submit transaction\n     * along with a signature from the chipId commiting to a block the signature was generated. This is to prevent\n     * any replay attacks. If the transaction isn't submitted within the MAX_BLOCK_WINDOW from the commited block\n     * this function will revert. Additionally, the chip's ERS node owner is updated to maintain state consistency.\n     *\n     * @param _chipId           The chipId to set the owner for\n     * @param _newOwner         The address of the new chip owner\n     * @param _commitBlock      The block the signature is tied to (used to put a time limit on the signature)\n     * @param _signature        The signature generated by the chipId (should just be a signature of the commitBlock)\n     */\n    function setOwner(\n        address _chipId,\n        address _newOwner,\n        uint256 _commitBlock,\n        bytes calldata _signature\n    )\n        public\n        override\n    {   \n        // Validations happen in ClaimedPBT, ERC721 doesn't allow transfers to the zero address\n        ClaimedPBT.setOwner(_chipId, _newOwner, _commitBlock, _signature);\n        _setERSOwnerForChip(_chipId, _newOwner);\n    }\n\n    /* ============ External Admin Functions ============ */\n\n    /**\n     * @notice ONLY OWNER: Initialize ChipRegistry contract with ERS and Services Registry addresses. Required due to order of operations\n     * during deploy.\n     *\n     * @param _ers                       Address of the ERS contract\n     * @param _servicesRegistry          Address of the ServicesRegistry contract\n     * @param _developerRegistry               Address of the DeveloperRegistry contract\n     */\n    function initialize(IERS _ers, IServicesRegistry _servicesRegistry, IDeveloperRegistry _developerRegistry) external onlyOwner {\n        require(!initialized, \"Contract already initialized\");\n        ers = _ers;\n        servicesRegistry = _servicesRegistry;\n        developerRegistry = _developerRegistry;\n\n        initialized = true;\n        emit RegistryInitialized(address(_ers), address(_servicesRegistry), address(_developerRegistry));\n    }\n\n    /**\n     * @notice ONLY OWNER: Add a new gateway URL to the array of gateway URLs. This array returns different URLs the client can call to\n     * get the data to resolve an unclaimed chip. The client can then use the data returned from the URL to call resolveUnclaimedChip.\n     *\n     * @param _gatewayUrl       The URL to add to the array of gateway URLs\n     */\n    function addGatewayURL(string memory _gatewayUrl) external onlyOwner {\n        require(!gatewayUrls.contains(_gatewayUrl), \"Gateway URL already added\");\n\n        gatewayUrls.push(_gatewayUrl);\n        emit GatewayURLAdded(_gatewayUrl);\n    }\n\n    /**\n     * @notice ONLY OWNER: Remove a gateway URL from the array of gateway URLs. This array returns different URLs the client can call to\n     * get the data to resolve an unclaimed chip. The client can then use the data returned from the URL to call resolveUnclaimedChip.\n     *\n     * @param _gatewayUrl       The URL to remove from the array of gateway URLs\n     */\n    function removeGatewayURL(string memory _gatewayUrl) external onlyOwner {\n        require(gatewayUrls.contains(_gatewayUrl), \"Gateway URL not in array\");\n\n        gatewayUrls.removeStorage(_gatewayUrl);\n        emit GatewayURLRemoved(_gatewayUrl);\n    }\n\n    /**\n     * @notice ONLY OWNER: Update the maximum amount of time a chip can be locked into a service for beyond the project's creation timestamp\n     *\n     * @param _maxLockinPeriod         The new maximum amount of time a chip can be locked into a service for beyond the project's creation timestamp\n     */\n    function updateMaxLockinPeriod(uint256 _maxLockinPeriod) external onlyOwner {\n        require(_maxLockinPeriod > 0, \"Invalid lockin period\");\n\n        maxLockinPeriod = _maxLockinPeriod;\n        emit MaxLockinPeriodUpdated(_maxLockinPeriod);\n    }\n\n    /* ============ View Functions ============ */\n    \n    /**\n     * @notice Resolve chip following EIP-3668 conventions. If the chip has been claimed, return the primary service content.\n     * If the chip hasn't been claimed then revert with an OffchainLookup error (per EIP-3668). The client can read the error\n     * and use the contents to find the required information to submit to the resolveUnclaimedChip function. This function will\n     * then return the either a bootloader app or content associated with the chip depending on if it has been included in a\n     * project enrollment.\n     *\n     * @param _chipId           The chip public key\n     * @return                  The content associated with the chip (if chip has been claimed already)\n     */\n    function resolveChipId(address _chipId) external view returns (IServicesRegistry.Record[] memory) {\n        if (_exists(_chipId)) {\n            return servicesRegistry.getPrimaryServiceContent(_chipId);\n        } else {\n            revert OffchainLookup(\n                address(this),\n                gatewayUrls,\n                abi.encodePacked(_chipId),\n                this.resolveUnclaimedChip.selector,\n                abi.encode(_chipId)\n            );\n        }\n    }\n\n    /**\n     * @notice Callback function for resolving unclaimed chip following EIP-3668 conventions. If the chip has been enrolled in\n     * a project and has valid certificates then return the claim app for that project. Otherwise, get the bootloader app associated\n     *  with the chip from the ManufacturerRegistry and return that. The _response parameter is structured in the following way:\n     * | developerEntries (uint256) | data (bytes) | where data is structured as follows:\n     * | [developerEntry[0],..., developerEntry[n], manufacturerValidation] | where developerEntry is structured as follows:\n     * | enrollmentId (bytes32) | projectRegistrar (address) | DeveloperMerkleInfo | developerInclusionProof | custodyProof\n     *\n     * @param _response         The response from the offchain lookup\n     * @param _extraData        Extra data required to resolve the unclaimed chip\n     * @return                  The bootloader app or content associated with the chip\n     */\n    function resolveUnclaimedChip(\n        bytes calldata _response,\n        bytes calldata _extraData\n    )\n        external\n        view\n        returns(IServicesRegistry.Record[] memory)\n    {   \n        address chipId = abi.decode(_extraData, (address));\n\n        if(_exists(chipId)) {\n            return servicesRegistry.getPrimaryServiceContent(chipId);\n        }\n\n        (\n            uint8 developerEntries,\n            bytes[] memory entries\n        ) = abi.decode(_response, (uint8, bytes[]));\n        uint8 entryLength = uint8(entries.length);\n\n        // Check that the response at least has a manufacturerValidation entry\n        require(entryLength == developerEntries + 1, \"Invalid response length\");\n\n        // Cycle through Developer entries and check if any are valid, return first valid entry. If there is no valid Developer entry then\n        // check the manufacturerValidation entry and return bootloader app. Most likely reason for a malicious invalid entry\n        // is not being able to create valid developerCustodyProof.\n        if (developerEntries > 0) {\n            for (uint8 i = 0; i < entryLength - 1; ++i) {\n                (\n                    bytes32 enrollmentId,\n                    IProjectRegistrar projectRegistrar,\n                    DeveloperMerkleInfo memory developerMerkleInfo,\n                    bytes memory developerInclusionProof,\n                    bytes memory developerCustodyProof\n                ) = abi.decode(entries[i], (bytes32, IProjectRegistrar, DeveloperMerkleInfo, bytes, bytes));\n\n                (bool validCertificates, ) = _areValidCertificates(\n                    chipId,\n                    projectEnrollments[projectRegistrar].projectPublicKey,\n                    developerInclusionProof,\n                    developerCustodyProof\n                );\n\n                bool validProof = _isValidDeveloperMerkleProof(\n                    chipId,\n                    developerMerkleInfo,\n                    enrollmentId,\n                    projectEnrollments[projectRegistrar].merkleRoot\n                );\n                if (validProof && validCertificates) {\n                    return servicesRegistry.getServiceContent(chipId, developerMerkleInfo.serviceId);\n                }\n            }\n        }\n        // If no valid Developer entries then we know the chip is not enrolled in a project and we can return the bootloader app\n        ManufacturerValidation memory manufacturerValidation = abi.decode(entries[entryLength - 1], (ManufacturerValidation));\n\n        _validateManufacturerMerkleProof(chipId, manufacturerValidation);\n\n        IServicesRegistry.Record[] memory bootloaderResponse = new IServicesRegistry.Record[](1);\n        bootloaderResponse[0] = IServicesRegistry.Record({\n            recordType: REDIRECT_URL_RECORDTYPE,\n            content: bytes(manufacturerRegistry.getEnrollmentBootloaderApp(manufacturerValidation.enrollmentId))\n        });\n\n        return bootloaderResponse;\n    }\n\n    /**\n     * @notice Get tokenUri from tokenId. TokenURI associated with primary service takes precedence, if no tokenURI as\n     * part of primary service then fail over to tokenURI defined in ClaimedPBT.\n     *\n     * @param _tokenId          Chip's tokenId\n     * @return                  TokenUri\n     */\n    function tokenURI(uint256 _tokenId) public view override(ClaimedPBT, IERC721Metadata) returns (string memory) {\n        string memory tokenUri = _getChipPrimaryServiceContentByRecordType(tokenIdToChipId[_tokenId], URI_RECORDTYPE);\n        return bytes(tokenUri).length == 0 ? ClaimedPBT.tokenURI(_tokenId) : tokenUri;\n    }\n\n    /**\n     * @notice Get tokenUri from chip address. TokenURI associated with primary service takes precedence, if no tokenURI as\n     * part of primary service then fail over to tokenURI defined in ClaimedPBT.\n     *\n     * @param _chipId           Chip's address\n     * @return                  TokenUri\n     */\n    function tokenURI(address _chipId) public view override returns (string memory) {\n        string memory tokenUri = _getChipPrimaryServiceContentByRecordType(_chipId, URI_RECORDTYPE);\n        return bytes(tokenUri).length == 0 ? ClaimedPBT.tokenURI(_chipId) : tokenUri;\n    }\n\n    function getGatewayUrls() external view returns(string[] memory) {\n        return gatewayUrls;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Get ERS node from tokenData and then sets the new Owner of the chip on the ERSRegistry.\n     */\n    function _setERSOwnerForChip(address _chipId, address _newOwner) internal {\n        (bytes32 chipErsNode, ) = _decodeTokenData(chipTable[_chipId].tokenData);\n        ers.setNodeOwner(chipErsNode, _newOwner);\n    }\n\n    /**\n     * Check that certificates passed as part of claim are valid. Developer cert is valid if the project public key signed\n     * the address of the chip. We then check the validity of the signed certificate which is the project public key\n     * signed by the chip.\n     */\n    function _validateCertificates(\n        address _chipId,\n        address _projectPublicKey,\n        bytes memory _developerInclusionProof,\n        bytes memory _developerCustodyProof\n    )\n        internal\n        view\n    {\n        (bool validCertificates, string memory errorMessage) = _areValidCertificates(\n            _chipId,\n            _projectPublicKey,\n            _developerInclusionProof,\n            _developerCustodyProof\n        );\n\n        require(validCertificates, errorMessage);\n    }\n\n    /**\n     * Check that certificates passed as part of claim are valid. Developer cert is valid if the project public key signed\n     * the address of the chip. We then check the validity of the signed certificate which is the project public key\n     * signed by the chip. If one of the certificates is invalid we return false and bubble up the error message.\n     *\n     * @return  bool    Whether or not the certificates are valid\n     * @return  string  Error message if certificates are invalid\n     */\n    function _areValidCertificates(\n        address _chipId,\n        address _projectPublicKey,\n        bytes memory _developerInclusionProof,\n        bytes memory _developerCustodyProof\n    )\n        internal\n        view\n        returns (bool, string memory)\n    {\n        // .toEthSignedMessageHash() prepends the message with \"\\x19Ethereum Signed Message:\\n\" + message.length and hashes message\n        bytes32 developerInclusionProofHash = abi.encodePacked(_chipId).toEthSignedMessageHash();\n        bytes32 signedCertHash = abi.encodePacked(_projectPublicKey).toEthSignedMessageHash();\n\n        if (!_projectPublicKey.isValidSignatureNow(developerInclusionProofHash, _developerInclusionProof)) {\n            return (false, \"Invalid Developer certificate\");\n        } else if (!_chipId.isValidSignatureNow(signedCertHash, _developerCustodyProof)) {\n            return (false, \"Invalid custody proof\");\n        } else {\n            return (true, \"\");\n        }\n    }\n\n    /**\n     * Validate inclusion in Manufacturer's chip enrollment\n     */\n    function _validateManufacturerMerkleProof(\n        address chipId,\n        ManufacturerValidation memory _manufacturerValidation\n    )\n        internal\n        view\n    {\n        bool isEnrolledChip = manufacturerRegistry.isEnrolledChip(\n            _manufacturerValidation.enrollmentId,\n            _manufacturerValidation.mIndex,\n            chipId,\n            _manufacturerValidation.manufacturerProof\n        );\n        require(isEnrolledChip, \"Chip not enrolled with ManufacturerRegistry\");\n    }\n\n    /**\n     * Indicate inclusion in Developer's merkle tree\n     */\n    function _isValidDeveloperMerkleProof(\n        address _chipId,\n        DeveloperMerkleInfo memory _merkleProofInfo,\n        bytes32 _enrollmentId,\n        bytes32 _merkleRoot\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        bytes32 node = keccak256(\n            bytes.concat(keccak256(\n                abi.encode(\n                    _merkleProofInfo.developerIndex,\n                    _chipId,\n                    _enrollmentId,\n                    _merkleProofInfo.lockinPeriod,\n                    _merkleProofInfo.serviceId,\n                    _merkleProofInfo.tokenUri\n                )\n            ))\n        );\n\n        return MerkleProof.verify(_merkleProofInfo.developerProof, _merkleRoot, node);\n    }\n\n    /**\n     * Validate inclusion in Developer's merkle tree\n     */\n    function _validateDeveloperMerkleProof(\n        address _chipId,\n        DeveloperMerkleInfo memory _merkleProofInfo,\n        bytes32 _enrollmentId,\n        bytes32 _merkleRoot\n    )\n        internal\n        pure\n    {\n        require(_isValidDeveloperMerkleProof(_chipId, _merkleProofInfo, _enrollmentId, _merkleRoot), \"Invalid Developer merkle proof\");\n    }\n\n    /**\n     * @notice Grab passed record type of primary service. For purposes of use within this contract we convert bytes\n     * to string\n     *\n     * @param _chipId          Chip's address\n     * @param _recordType      Bytes32 hash representing the record type being queried\n     * @return                 Content cotained in _recordType\n     */\n    function _getChipPrimaryServiceContentByRecordType(\n        address _chipId,\n        bytes32 _recordType\n    )\n        internal\n        view\n        returns (string memory)\n    {\n        bytes memory content = servicesRegistry.getPrimaryServiceContentByRecordtype(_chipId, _recordType);\n        return string(content);\n    }\n\n    /**\n     * ClaimedPBT has an unstructured \"tokenData\" field that for our implementation we will populate with the chip's\n     * ERS node and the manufacturer enrollmentId of the chip. This function structures that data.\n     */\n    function _encodeTokenData(bytes32 _ersNode, bytes32 _enrollmentId) internal pure returns (bytes memory) {\n        // Since no addresses there's no difference between abi.encode and abi.encodePacked\n        return abi.encode(_ersNode, _enrollmentId);\n    }\n\n    /**\n     * ClaimedPBT has an unstructured \"tokenData\" field that for our implementation we will populate with the chip's\n     * ERS node and the manufacturer enrollmentId of the chip. This function interprets that data.\n     */\n    function _decodeTokenData(bytes memory _tokenData) internal pure returns (bytes32, bytes32) {\n        return abi.decode(_tokenData, (bytes32, bytes32));\n    }\n}\n"
    },
    "contracts/DeveloperRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { IChipRegistry } from \"./interfaces/IChipRegistry.sol\";\nimport { IERS } from \"./interfaces/IERS.sol\";\nimport { IProjectRegistrar } from \"./interfaces/IProjectRegistrar.sol\";\nimport { ITransferPolicy } from \"./interfaces/ITransferPolicy.sol\";\nimport { IDeveloperRegistry } from \"./interfaces/IDeveloperRegistry.sol\";\n\n/**\n * @title DeveloperRegistrar\n * @author Arx\n *\n * @notice Contract that coordinates adding a new project for a Developer. Each Developer has their own DeveloperRegistrar which is associated\n * with a .ers subnode in the ERS registry ([developer].ers). When adding a new project a subnode under the developer.ers sub-\n * domain is added ([projectName].developer.ers) and the project is enrolled in the ChipRegistry.\n */\ncontract DeveloperRegistrar is Ownable {\n\n    /* ============ Events ============ */\n    event ProjectAdded(\n        address indexed projectRegistrar,\n        bytes32 projectRootNode,\n        bytes32 merkleRoot,\n        address projectPublicKey,\n        address transferPolicy,\n        string projectClaimDataUri\n    );\n    event RegistrarInitialized(bytes32 rootNode);\n\n    /* ============ State Variables ============ */\n    IChipRegistry public immutable chipRegistry;\n    IERS public immutable ers;\n    IDeveloperRegistry public immutable developerRegistry;\n\n    bool public initialized;\n    bytes32 public rootNode;            // Node off which all Developer project names will branch (ie [projectName].[developerName].ers)\n    address[] public projects;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructor for DeveloperRegistrar. Sets the owner and ChipRegistry.\n     *\n     * @param _owner                Owner of the DeveloperRegistrar. This address is responsible for adding new projects\n     * @param _chipRegistry         ChipRegistry contract\n     * @param _ers                  ERS registry\n     * @param _developerRegistry    DeveloperRegistry contract\n     */\n    constructor(\n        address _owner,\n        IChipRegistry _chipRegistry,\n        IERS _ers,\n        IDeveloperRegistry _developerRegistry\n    )\n        Ownable()\n    {\n        chipRegistry = _chipRegistry;\n        ers = _ers;\n        developerRegistry = _developerRegistry;\n        transferOwnership(_owner);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice ONLY Developer REGISTRY: Initialize DeveloperRegistrar contract with root node. Required due to order of operations\n     * during deploy.\n     *\n     * @param _rootNode         Root node of the Developer\n     */\n    function initialize(bytes32 _rootNode) external {\n        require(IDeveloperRegistry(msg.sender) == developerRegistry, \"Caller must be DeveloperRegistry\");\n        require(!initialized, \"Contract already initialized\");\n        \n        rootNode = _rootNode;\n        initialized = true;\n        emit RegistrarInitialized(_rootNode);\n    }\n\n    /**\n     * @notice ONLY OWNER: Add a new project to the Developer. Creates a new subnode in the ENS registry and adds the project\n     * to the ChipRegistry. DeveloperRegistrar's DO NOT have the ability to overwrite their subnodes in ERS, hence if a _nameHash\n     * is already taken, this function will revert. Ownership proof is checked in the ChipRegistry.\n     *\n     * @param _nameHash                     Namehash of the project\n     * @param _projectRegistrar             ProjectRegistrar contract\n     * @param _merkleRoot                   Merkle root of the project's chip ownership\n     * @param _projectPublicKey             Public key of the project\n     * @param _transferPolicy               Transfer policy of the project\n     * @param _projectOwnershipProof        Signed hash of the _projectRegistrar address by the _projectPublicKey\n     * @param _projectClaimDataUri          URI pointing to location of off-chain data required to claim chips\n     */\n    function addProject(\n        bytes32 _nameHash,\n        IProjectRegistrar _projectRegistrar,\n        bytes32 _merkleRoot,\n        address _projectPublicKey,\n        ITransferPolicy _transferPolicy,\n        bytes calldata _projectOwnershipProof,\n        string calldata _projectClaimDataUri\n    )\n        external\n        onlyOwner()\n    {\n        require(_merkleRoot != bytes32(0), \"Invalid merkle root\");\n        require(_projectPublicKey != address(0), \"Invalid project public key\");\n        require(address(_projectRegistrar) != address(0), \"Invalid project registrar address\");\n\n        // Create subnode in ENS registry; if _nameHash has already been used it will revert here\n        bytes32 projectNode = ers.createSubnodeRecord(\n            rootNode,\n            _nameHash,\n            address(_projectRegistrar),\n            address(_projectRegistrar)\n        );\n\n        // Call project registrar to set root node (this is an untrusted contract!)\n        _projectRegistrar.setRootNode(projectNode);\n        projects.push(address(_projectRegistrar));\n\n        chipRegistry.addProjectEnrollment(\n            _projectRegistrar,\n            _projectPublicKey,\n            _transferPolicy,\n            _merkleRoot,\n            _projectOwnershipProof,\n            _projectClaimDataUri\n        );\n\n        emit ProjectAdded(\n            address(_projectRegistrar),\n            projectNode,\n            _merkleRoot,\n            _projectPublicKey,\n            address(_transferPolicy),\n            _projectClaimDataUri\n        );\n    }\n\n    /* ============ View Functions ============ */\n\n    function getProjects() external view returns(address[] memory) {\n        return projects;\n    }\n}\n"
    },
    "contracts/DeveloperRegistrarFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { IChipRegistry } from \"./interfaces/IChipRegistry.sol\";\nimport { IERS } from \"./interfaces/IERS.sol\";\nimport { IDeveloperRegistry } from \"./interfaces/IDeveloperRegistry.sol\";\nimport { DeveloperRegistrar } from \"./DeveloperRegistrar.sol\";\n\n/**\n * @title DeveloperRegistrarFactory\n * @author Arx\n *\n * @notice Contract used to deploy new DeveloperRegistrars. Callable only by the DeveloperRegistry.\n */\ncontract DeveloperRegistrarFactory {\n\n    /* ============ Events ============ */\n    event DeveloperRegistrarDeployed(address indexed developerRegistrar, address indexed owner);\n\n    /* ============ State Variables ============ */\n    IChipRegistry public immutable chipRegistry;\n    IERS public immutable ers;\n    IDeveloperRegistry public immutable developerRegistry;\n\n    /* ============ Constructor ============ */\n    constructor(IChipRegistry _chipRegistry, IERS _ers, IDeveloperRegistry _developerRegistry) {\n        chipRegistry = _chipRegistry;\n        ers = _ers;\n        developerRegistry = _developerRegistry;\n    }\n\n    /* ============ External Functions ============ */\n    function deployRegistrar(address _owner)\n        external\n        returns(address)\n    {\n        require(IDeveloperRegistry(msg.sender) == developerRegistry, \"Caller must be DeveloperRegistry\");\n\n        DeveloperRegistrar newRegistrar = new DeveloperRegistrar(_owner, chipRegistry, ers, developerRegistry);\n        emit DeveloperRegistrarDeployed(address(newRegistrar), _owner);\n        return address(newRegistrar);\n    }\n}\n"
    },
    "contracts/DeveloperRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { AddressArrayUtils } from \"./lib/AddressArrayUtils.sol\";\nimport { IERS } from \"./interfaces/IERS.sol\";\nimport { IManufacturerRegistry } from \"./interfaces/IManufacturerRegistry.sol\";\nimport { IDeveloperRegistrar } from \"./interfaces/IDeveloperRegistrar.sol\";\nimport { IDeveloperRegistrarFactory } from \"./interfaces/IDeveloperRegistrarFactory.sol\";\n\n/**\n * @title DeveloperRegistry\n * @author Arx\n *\n * @notice Contract responsible for tracking and permissioning Developers. Developers are given the ability to create a new DeveloperRegistrar by\n * governance. When creating a new Registrar the Developer is given a new [x].ers name. Governance has the ability to revoke Developer permissions\n * and reassign the ERS name to a new Developer.\n */\ncontract DeveloperRegistry is Ownable {\n\n    using AddressArrayUtils for address[];\n\n    /* ============ Events ============ */\n    event DeveloperRegistrarAdded(address indexed developerRegistrar, address indexed owner, bytes32 rootNode);\n    event DeveloperRegistrarRevoked(address indexed developerRegistrar, bytes32 subnode, bytes32 _nameHash);\n    event DeveloperAllowed(address indexed developerOwner, bytes32 nameHash);\n    event DeveloperDisallowed(address indexed developerOwner);\n    event RegistrarFactoryAdded(address indexed factory);\n    event RegistrarFactoryRemoved(address indexed factory);\n    event RegistryInitialized(address ers);\n\n    /* ============ Modifiers ============ */\n    modifier onlyNameGovernor() {\n        require(msg.sender == nameGovernor, \"Only the Name Governor can call this function\");\n        _;\n    }\n    \n    /* ============ Constants ============ */\n    // Equal to keccak256(abi.encodePacked(uint256(0), keccak256(\"ers\")))\n    bytes32 public constant ROOT_NODE = 0xda53397877d78746657194546b25f20b5c2e580045028a6fa27f07cf94e704ba;\n    \n    /* ============ State Variables ============ */\n    IERS public ersRegistry;\n    bool public initialized;\n    address public nameGovernor;\n\n    mapping(IDeveloperRegistrarFactory=>bool) public registrarFactories;  // Mapping indicating if address is a registered DeveloperRegistrarFactory\n    mapping(address=>bytes32) public pendingDevelopers;                   // Mapping of Developer owner address to the nameHash they want for their \n                                                                          // DeveloperRegistrar\n    mapping(address=>bool) public isDeveloperRegistrar;                   // Mapping indicating if address is a DeveloperRegistrar\n    address[] internal developerRegistrars;\n\n    /* ============ Constructor ============ */\n    constructor(address _governance) Ownable() {\n        transferOwnership(_governance);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice ONLY OWNER: Initialize ChipRegistry contract with ERS and Services Registry addresses. Required due to order of operations\n     * during deploy.\n     *\n     * @param _ers                       Address of the ERS contract\n     * @param _factories                 Array of DeveloperRegistrarFactory contracts\n     * @param _nameGovernor              Address of the Name Governor which can assign names to Developers\n     */\n    function initialize(\n        IERS _ers,\n        IDeveloperRegistrarFactory[] calldata _factories,\n        address _nameGovernor\n    )\n        external\n        onlyOwner\n    {\n        require(!initialized, \"Contract already initialized\");\n        ersRegistry = _ers;\n        nameGovernor = _nameGovernor;\n\n        for (uint256 i = 0; i < _factories.length; ++i) {\n            _addRegistrarFactory(_factories[i]);\n        }\n\n        initialized = true;\n        emit RegistryInitialized(address(_ers));\n    }\n\n    /**\n     * @notice Create a new DeveloperRegistrar for a Developer. In order to call, the calling address must be approved by governance. Once called\n     * the Developer must be added again if they want to launch a new DeveloperRegistrar. This function assigns the DeveloperRegistrar it's own\n     * .ers name. The passed nameHash must be different than any other DeveloperRegistrar's nameHash.\n     *\n     * @param _factory              Address of the DeveloperRegistrarFactory to use for deploying the DeveloperRegistrar\n     */\n    function createNewDeveloperRegistrar(IDeveloperRegistrarFactory _factory) external returns(address) {\n        require(registrarFactories[_factory], \"Factory must be approved DeveloperRegistrarFactory\");\n        require(pendingDevelopers[msg.sender] != bytes32(0), \"Caller must be approved Developer address\");\n\n        // Save Developers nameHash in memory and then delete from storage\n        bytes32 nameHash = pendingDevelopers[msg.sender];\n        delete pendingDevelopers[msg.sender];\n\n        // Passing the owner of the new Registrar to the Factory. Caller is set as owner. This can be transferred to a multisig later.\n        address newRegistrar = IDeveloperRegistrarFactory(_factory).deployRegistrar(msg.sender);\n        bytes32 registrarRootNode = ersRegistry.createSubnodeRecord(ROOT_NODE, nameHash, newRegistrar, newRegistrar);\n\n        // Registrar is a trusted contract that we initialize with a root node\n        IDeveloperRegistrar(newRegistrar).initialize(registrarRootNode);\n\n        isDeveloperRegistrar[newRegistrar] = true;\n        developerRegistrars.push(newRegistrar);\n\n        emit DeveloperRegistrarAdded(newRegistrar, msg.sender, registrarRootNode);\n        return newRegistrar;\n    }\n\n    /**\n     * @notice ONLY OWNER: Revoke permissions from a DeveloperRegistrar. This resets the owner and resolver to the zero address in the ERSRegistry\n     * and removes tracking of the DeveloperRegistrar within the DeveloperRegistry (delete from developerRegistrars array and isDeveloperRegistrar\n     * mapping). \n     *\n     * @param _developerRegistrar   Address of the DeveloperRegistrar that is being revoked\n     * @param _nameHash             Bytes32 hash of the ERS name the Developer wants for their Registrar\n     */\n    function revokeDeveloperRegistrar(address _developerRegistrar, bytes32 _nameHash) external onlyOwner {\n        require(isDeveloperRegistrar[_developerRegistrar], \"Not a DeveloperRegistrar\");\n\n        // Validate that _nameHash is the nameHash of the DeveloperRegistrar. We can do this check because we know the DeveloperRegistrar's root node\n        // cannot be updated since it a trusted contract.\n        bytes32 subnodeHash = ersRegistry.getSubnodeHash(ROOT_NODE, _nameHash);\n        bytes32 registrarRootNode = IDeveloperRegistrar(_developerRegistrar).rootNode();\n        require(subnodeHash == registrarRootNode, \"Passed subnode does not match Registrar's root node\");\n\n        ersRegistry.deleteSubnodeRecord(ROOT_NODE, _nameHash);\n\n        delete isDeveloperRegistrar[_developerRegistrar];\n        developerRegistrars.removeStorage(_developerRegistrar);\n        \n        emit DeveloperRegistrarRevoked(_developerRegistrar, subnodeHash, _nameHash);\n    }\n\n    /**\n     * @notice ONLY OWNER: Add a new address that can create a new DeveloperRegistrar. Since ERS names have value we want them to commit to a name\n     * up front. The passed nameHash must be different than any other DeveloperRegistrar's nameHash and not bytes32(0).\n     *\n     * @param _developerOwner       Address that has the ability to create a new DeveloperRegistrar with the below nameHash\n     * @param _nameHash             Bytes32 hash of the ERS name the Developer wants for their Registrar\n     */\n    function addAllowedDeveloper(address _developerOwner, bytes32 _nameHash) external onlyNameGovernor {\n        require(pendingDevelopers[_developerOwner] == bytes32(0), \"Developer already allowed\");\n        // can't allow zero bytes since it's the default value for pendingDevelopers. Will not allow someone to deploy a Registrar with zero\n        // bytes name.\n        require(_nameHash != bytes32(0), \"Invalid name hash\");\n        require(_developerOwner != address(0), \"Invalid Developer owner address\");\n        require(ersRegistry.getSubnodeOwner(ROOT_NODE, _nameHash) == address(0), \"Name already taken\");\n\n        pendingDevelopers[_developerOwner] = _nameHash;\n        emit DeveloperAllowed(_developerOwner, _nameHash);\n    }\n\n    /**\n     * @notice ONLY OWNER: Remove an address from creating a new DeveloperRegistrar. \n     *\n     * @param _developerOwner       Address that has the ability to create a new DeveloperRegistrar with the below nameHash\n     */\n    function removeAllowedDeveloper(address _developerOwner) external onlyNameGovernor {\n        require(pendingDevelopers[_developerOwner]!= bytes32(0), \"Developer not allowed\");\n\n        delete pendingDevelopers[_developerOwner];\n        emit DeveloperDisallowed(_developerOwner);\n    }\n\n    /**\n     * @notice ONLY OWNER: Add a new DeveloperRegistrarFactory that can be used for creating new DeveloperRegistrars. \n     *\n     * @param _factory             Address of DeveloperRegistrarFactory to add\n     */\n    function addRegistrarFactory(IDeveloperRegistrarFactory _factory) external onlyOwner {\n        _addRegistrarFactory(_factory);\n    }\n\n    /**\n     * @notice ONLY OWNER: Remove a DeveloperRegistrarFactory so that it can't be used for creating new DeveloperRegistrars.\n     *\n     * @param _factory             Address of DeveloperRegistrarFactory to add\n     */\n    function removeRegistrarFactory(IDeveloperRegistrarFactory _factory) external onlyOwner {\n        require(registrarFactories[_factory], \"Factory not added\");\n\n        delete registrarFactories[_factory];\n        emit RegistrarFactoryRemoved(address(_factory));\n    }\n\n    /* ============ View Functions ============ */\n    \n    function getDeveloperRegistrars() external view returns(address[] memory) {\n        return developerRegistrars;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _addRegistrarFactory(IDeveloperRegistrarFactory _factory) internal {\n        require(!registrarFactories[_factory], \"Factory already added\");\n        require(address(_factory) != address(0), \"Invalid factory address\");\n\n        registrarFactories[_factory] = true;\n        emit RegistrarFactoryAdded(address(_factory));\n    }\n}\n"
    },
    "contracts/ERSRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { IChipRegistry } from \"./interfaces/IChipRegistry.sol\";\nimport { IDeveloperRegistry } from \"./interfaces/IDeveloperRegistry.sol\";\n\n/**\n * @title ERSRegistry\n * @author Arx\n *\n * @notice Fork of ENSRegistry with adapted data structures and accessiblity logic in order to conform to needs of ERS. Node\n * owners can create any subnode. A node tracks the owner of the node and the address the node resolves to. Within the\n * context of ERS a resolver represents either a smart contract OR a chip. The owner has the ability to create any subnodes\n * of its choosing, however only the DeveloperRegistry is able to change both the owner and the resolver for a given node once\n * created. The ChipRegistry is able to change the owner of a node (signifying a transfer of a chip) but is not able to \n * change the resolver. These permissions are put in place in order to maintain a track record of authenticity for chips\n * while allowing the DeveloperRegistry to re-assign sub-domains to new DeveloperRegistrars. Note that if a DeveloperRegistry's\n * subnode is reassigned to a new DeveloperRegistrar the new DeveloperRegistrar CANNOT overwrite the nodes created by the\n * previous node owner.\n */\ncontract ERSRegistry {\n\n    /* ============ Events ============ */\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed subnode, bytes32 indexed nameHash, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    /* ============ Structs ============ */\n    struct Record {\n        address owner;\n        address resolver;\n    }\n\n    /* ============ Modifiers ============ */\n    // Permits modifications only by the owner of the specified node.\n    modifier authorised(bytes32 _node) {\n        address owner = records[_node].owner;\n        require(owner == msg.sender, \"Must be node owner\");\n        _;\n    }\n\n    /* ============ State Variables ============ */\n    IChipRegistry public immutable chipRegistry;\n    IDeveloperRegistry public immutable developerRegistry;\n    \n    mapping(bytes32 => Record) public records;\n    \n    /* ============ Constructor ============ */\n\n    /**\n     * @dev Constructs a new ERS registry.\n     */\n    constructor(IChipRegistry _chipRegistry, IDeveloperRegistry _developerRegistry) {\n        chipRegistry = _chipRegistry;\n        developerRegistry = _developerRegistry;\n        records[0x0].owner = msg.sender;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @dev Sets the record for a new subnode. May only be called by owner of node (checked in _setSubnodeOwner).\n     *\n     * @param _node     The parent node.\n     * @param _nameHash The hash of the nameHash specifying the subnode.\n     * @param _owner    The address of the new owner.\n     * @param _resolver The address of the resolver.\n     * @return The newly created subnode hash\n     */\n    function createSubnodeRecord(\n        bytes32 _node,\n        bytes32 _nameHash,\n        address _owner,\n        address _resolver\n    )\n        external\n        virtual\n        authorised(_node)\n        returns(bytes32)\n    {\n        bytes32 subnode = _calculateSubnode(_node, _nameHash);\n        require(_owner != address(0), \"New owner cannot be null address\");\n        require(!recordExists(subnode), \"Subnode already exists\");\n\n        _setOwner(subnode, _owner);\n        _setResolver(subnode, _resolver);\n\n        emit NewOwner(_node, subnode, _nameHash, _owner);\n        return subnode;\n    }\n\n    /**\n     * @dev ONLY Developer REGISTRY: Deletes the record for an already created subnode. Developer Registry must be the owner of the node so as to not\n     * accidentally delete a non DeveloperRegistrar subnode.\n     *\n     * @param _node     The parent node.\n     * @param _nameHash The hash of the nameHash specifying the subnode.\n     */\n    function deleteSubnodeRecord(\n        bytes32 _node,\n        bytes32 _nameHash\n    )\n        external\n        virtual\n        authorised(_node)\n    {\n        require(msg.sender == address(developerRegistry), \"Caller must be DeveloperRegistry\");\n\n        bytes32 subnode = _calculateSubnode(_node, _nameHash);\n        require(recordExists(subnode), \"Subnode does not exist\");\n\n        _setOwner(subnode, address(0));\n        _setResolver(subnode, address(0));\n\n        emit NewOwner(_node, subnode, _nameHash, address(0));\n    }\n\n    /**\n     * @dev ONLY CHIP REGISTRY: Transfers ownership of a node to a new address. Owner cannot directly call (unless root node),\n     * ChipRegistry must manage ownership changes for chips in order to keep state consistent between ChipRegistry and ERS.\n     *\n     * @param _node     The node to transfer ownership of.\n     * @param _newOwner The address of the new owner.\n     */\n    function setNodeOwner(\n        bytes32 _node,\n        address _newOwner\n    )\n        external\n        virtual\n    {\n        // if node isn't 0x0 then ChipRegistry must be caller, if it is then owner must be caller\n        address requiredCaller = _node == 0x0 ? records[_node].owner : address(chipRegistry);\n        require(msg.sender == requiredCaller, \"Caller must be ChipRegistry or owner of node\");\n        require(_newOwner != address(0), \"New owner cannot be null address\");\n        require(recordExists(_node), \"Node does not exist\");\n\n        _setOwner(_node, _newOwner);\n        emit Transfer(_node, _newOwner);\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     * @dev Validate that state has been correctly set for a chip. Used by ChipRegistry to validate that a ProjectRegistrar has\n     * set the correct state for a chip.\n     *\n     * @param _node     The specified node.\n     * @param _chipId   The specified chipId.\n     * @param _owner    The specified owner.\n     * @return bool indicating whether state is valid\n     */\n    function isValidChipState(\n        bytes32 _node,\n        address _chipId,\n        address _owner\n    )\n        external\n        virtual\n        view\n        returns(bool)\n    {\n        return (records[_node].owner == _owner && records[_node].resolver == _chipId);\n    }\n\n    /**\n     * @dev Returns the address that owns the specified node.\n     *\n     * @param _node     The specified node.\n     * @return address of the owner.\n     */\n    function getOwner(bytes32 _node) public view virtual returns (address) {\n        return records[_node].owner;\n    }\n\n    /**\n     * @dev Returns the address that owns the specified subnode.\n     *\n     * @param _node         The specified node.\n     * @param _nameHash     The specified nameHash.\n     * @return address of the owner.\n     */\n    function getSubnodeOwner(bytes32 _node, bytes32 _nameHash) external view virtual returns (address) {\n        bytes32 subnode = _calculateSubnode(_node, _nameHash);\n        return getOwner(subnode);\n    }\n\n    /**\n     * @dev Returns the address of the resolver for the specified node.\n     *\n     * @param _node     The specified node.\n     * @return address of the resolver.\n     */\n    function getResolver(bytes32 _node) external view virtual returns (address) {\n        return records[_node].resolver;\n    }\n\n    /**\n     * @dev Returns whether a record has been written to the registry for that node.\n     *\n     * @param _node The specified node.\n     * @return Bool if record exists\n     */\n    function recordExists(bytes32 _node) public view virtual returns (bool) {\n        return records[_node].owner != address(0);\n    }\n\n    /**\n     * @dev Returns the subnode hash of node + nameHash. This is the keccak256 hash of `node` + `nameHash`.\n     *\n     * @param _node     The specified node.\n     * @param _nameHash The specified nameHash.\n     */\n    function getSubnodeHash(bytes32 _node, bytes32 _nameHash) external pure returns (bytes32) {\n        return _calculateSubnode(_node, _nameHash);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    function _calculateSubnode(bytes32 _node, bytes32 _nameHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_node, _nameHash));\n    }\n\n    function _setOwner(bytes32 node, address owner) internal virtual {\n        records[node].owner = owner;\n    }\n\n    function _setResolver(bytes32 _node, address _resolver) internal virtual {\n        records[_node].resolver = _resolver;\n        emit NewResolver(_node, _resolver);\n    }\n}\n"
    },
    "contracts/governance/DeveloperNameGovernor.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\nimport { IDeveloperRegistry } from \"../interfaces/IDeveloperRegistry.sol\";\n\n/**\n * @title DeveloperNameGovernor\n * @notice Contract that coordinates adding a new project for a Developer. Each Developer has their own DeveloperRegistrar which is associated\n * with a .ers subnode in the ERS registry ([developer].ers). In order for a valid name claim the caller must submit a transaction with a valid\n * signature signed by the coordinator of this contract over hash(developerAddress, developerName).\n */\n\ncontract DeveloperNameGovernor is Ownable {\n\n    using ECDSA for bytes;\n    using SignatureChecker for address;\n\n    /* ============ Events ============ */\n    event NameCoordinatorUpdated(address newNameCoordinator);\n\n    /* ============ State Variables ============ */\n    IDeveloperRegistry public immutable developerRegistry;\n    address public nameCoordinator;\n\n    /* ============ Constructor ============ */\n    /**\n     * @notice Constructor for DeveloperNameGovernor. Sets the owner and DeveloperRegistry.\n     *\n     * @param _developerRegistry    DeveloperRegistry contract\n     * @param _nameCoordinator      Address of the signer of name claims\n     */\n    constructor(IDeveloperRegistry _developerRegistry, address _nameCoordinator)\n        Ownable()\n    {\n        developerRegistry = _developerRegistry;\n        nameCoordinator = _nameCoordinator;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice Claim a name for a developer. The caller must submit a transaction with a valid signature signed by the name coordinator. The\n     * name coordinator performs checks for name validity and availability.\n     *\n     * @param _developerName        ERS name of the developer\n     * @param _nameApprovalProof    Signature of the name coordinator over hash(msg.sender, developerName)\n     */\n    function claimName(\n        bytes32 _developerName,\n        bytes memory _nameApprovalProof\n    ) public {\n        // .toEthSignedMessageHash() prepends the message with \"\\x19Ethereum Signed Message:\\n\" + message.length and hashes message\n        address sender = msg.sender;\n        \n        bytes32 messageHash = abi.encodePacked(sender, _developerName).toEthSignedMessageHash();\n        require(nameCoordinator.isValidSignatureNow(messageHash, _nameApprovalProof), \"Invalid signature\");\n\n        developerRegistry.addAllowedDeveloper(sender, _developerName);\n    }\n\n    /**\n     * @notice ONLY OWNER: Remove a name claim for a developer.\n     *\n     * @param _developerOwner       Address of the developer owner\n     */\n    function removeNameClaim(address _developerOwner) public onlyOwner {\n        developerRegistry.removeAllowedDeveloper(_developerOwner);\n    }\n\n    /**\n     * @notice ONLY OWNER: Update the name coordinator.\n     *\n     * @param _newNameCoordinator       Address of the new name coordinator\n     */\n    function updateNameCoordinator(address _newNameCoordinator) public onlyOwner {\n        require(_newNameCoordinator != address(0), \"Address cannot be zero address\");\n        nameCoordinator = _newNameCoordinator;\n\n        emit NameCoordinatorUpdated(_newNameCoordinator);\n    }\n}\n"
    },
    "contracts/interfaces/IChipRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { IPBT } from \"../token/IPBT.sol\";\nimport { IProjectRegistrar } from \"./IProjectRegistrar.sol\";\nimport { ITransferPolicy } from \"./ITransferPolicy.sol\";\n\ninterface IChipRegistry is IPBT {\n\n    struct DeveloperMerkleInfo {\n        uint256 developerIndex;\n        bytes32 serviceId;\n        uint256 lockinPeriod;\n        string tokenUri;\n        bytes32[] developerProof;\n    }\n\n    struct ChipClaim {\n        address owner;\n        bytes32 ersNode;\n        DeveloperMerkleInfo developerMerkleInfo;\n    }\n\n    struct ManufacturerValidation {\n        bytes32 enrollmentId;\n        uint256 mIndex;\n        bytes32[] manufacturerProof;\n    }\n\n    function addProjectEnrollment(\n        IProjectRegistrar _projectRegistrar,\n        address _projectPublicKey,\n        ITransferPolicy _transferPolicy,\n        bytes32 _merkleRoot,\n        bytes calldata _signature,\n        string calldata _projectClaimDataUri\n    )\n        external;\n    \n    function claimChip(\n        address _chipId,\n        ChipClaim calldata _chipClaim,\n        ManufacturerValidation calldata _manufacturerValidation,\n        bytes calldata _developerInclusionProof,\n        bytes calldata _developerCustodyProof\n    )\n        external;\n}\n"
    },
    "contracts/interfaces/IDeveloperRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { IProjectRegistrar } from \"./IProjectRegistrar.sol\";\nimport { ITransferPolicy } from \"./ITransferPolicy.sol\";\n\ninterface IDeveloperRegistrar {\n    function initialize(bytes32 _rootNode) external;\n    function rootNode() external view returns (bytes32);\n    function addProject(\n        bytes32 _nameHash,\n        IProjectRegistrar _projectRegistrar,\n        bytes32 _merkleRoot,\n        address _projectPublicKey,\n        ITransferPolicy _transferPolicy,\n        bytes calldata _ownershipProof,\n        string calldata _projectClaimDataUri\n    )\n        external;\n}\n"
    },
    "contracts/interfaces/IDeveloperRegistrarFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\ninterface IDeveloperRegistrarFactory {\n    function deployRegistrar(address _owner) external returns(address);\n}\n"
    },
    "contracts/interfaces/IDeveloperRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\ninterface IDeveloperRegistry {\n    function addAllowedDeveloper(address _developerOwner, bytes32 _nameHash) external;\n    function removeAllowedDeveloper(address _developerOwner) external;\n    function isDeveloperRegistrar(address _registrar) external view returns(bool);\n}\n"
    },
    "contracts/interfaces/IERS.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\ninterface IERS {\n    function createSubnodeRecord(\n        bytes32 _node,\n        bytes32 _nameHash,\n        address _owner,\n        address _resolver\n    ) external returns(bytes32);\n\n    function deleteSubnodeRecord(\n        bytes32 _node,\n        bytes32 _nameHash\n    ) external;\n\n    function setNodeOwner(\n        bytes32 _node,\n        address _owner\n    ) external;\n\n    function isValidChipState(\n        bytes32 _node,\n        address _chipId,\n        address _owner\n    ) external view returns(bool);\n\n    function getSubnodeHash(\n        bytes32 _node,\n        bytes32 _nameHash\n    )\n        external\n        pure\n        returns (bytes32);\n\n    function getSubnodeOwner(\n        bytes32 _node,\n        bytes32 _nameHash\n    )\n        external\n        view\n        returns (address);\n}\n"
    },
    "contracts/interfaces/IManufacturerRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\ninterface IManufacturerRegistry {\n    function isEnrolledChip(\n        bytes32 _enrollmentId,\n        uint256 _index,\n        address _chipId,\n        bytes32[] calldata _merkleProof\n    )\n        external\n        view\n        returns (bool);\n\n    function getEnrollmentBootloaderApp(bytes32 _enrollmentId) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IProjectRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\ninterface IProjectRegistrar {\n    function setRootNode(\n        bytes32 _rootNode\n    )\n        external;\n}\n"
    },
    "contracts/interfaces/IServicesRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\ninterface IServicesRegistry {\n    struct Record {\n        bytes32 recordType;\n        bytes content;\n    }\n\n    struct Service {\n        bytes32 serviceId;\n        Record[] records;\n    }\n\n    struct ExpandedChipServices {\n        Service primaryService;\n        uint256 serviceTimelock;\n        Service[] secondaryServices;\n    }\n\n    function setInitialService(address _chipId, bytes32 _serviceId, uint256 _timelock) external;\n    function getPrimaryServiceContentByRecordtype(address _chipId, bytes32 _datatype) external view returns (bytes memory);\n    function getPrimaryServiceContent(address _chipId) external view returns (Record[] memory);\n    function getServiceContent(address _chipId, bytes32 _serviceId) external view returns (Record[] memory);\n}\n"
    },
    "contracts/interfaces/ITransferPolicy.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\ninterface ITransferPolicy {\n    function authorizeTransfer(\n        address _chipId,\n        address _sender,\n        address _chipOwner,\n        bytes calldata _payload,\n        bytes calldata _signature\n    ) external;\n}\n"
    },
    "contracts/lib/AddressArrayUtils.sol": {
      "content": "/*\n    Copyright 2020 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: MIT\n*/\n\npragma solidity ^0.8.17;\n\n/**\n * @title AddressArrayUtils\n * @author Set Protocol\n *\n * Utility functions to handle Address Arrays\n *\n * CHANGELOG:\n * - 4/21/21: Added validatePairsWithArray methods\n */\nlibrary AddressArrayUtils {\n\n    uint256 constant internal MAX_INT = 2**256 - 1;\n\n    /**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (MAX_INT, false);\n    }\n\n    /**\n    * Returns true if the value is present in the list. Uses indexOf internally.\n    * @param A The input array to search\n    * @param a The value to find\n    * @return Returns isIn for the first occurrence starting from index 0\n    */\n    function contains(address[] memory A, address a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n    * Returns true if there are 2 elements that are the same in an array\n    * @param A The input array to search\n    * @return Returns boolean for the first occurrence of a duplicate\n    */\n    function hasDuplicate(address[] memory A) internal pure returns(bool) {\n        require(A.length > 0, \"A is empty\");\n\n        for (uint256 i = 0; i < A.length - 1; i++) {\n            address current = A[i];\n            for (uint256 j = i + 1; j < A.length; j++) {\n                if (current == A[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The address to remove\n     * @return Returns the array with the object removed.\n     */\n    function remove(address[] memory A, address a)\n        internal\n        pure\n        returns (address[] memory)\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"Address not in array.\");\n        } else {\n            (address[] memory _A,) = pop(A, index);\n            return _A;\n        }\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The address to remove\n     */\n    function removeStorage(address[] storage A, address a)\n        internal\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"Address not in array.\");\n        } else {\n            uint256 lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\n            if (index != lastIndex) { A[index] = A[lastIndex]; }\n            A.pop();\n        }\n    }\n\n    /**\n    * Removes specified index from array\n    * @param A The input array to search\n    * @param index The index to remove\n    * @return Returns the new array and the removed entry\n    */\n    function pop(address[] memory A, uint256 index)\n        internal\n        pure\n        returns (address[] memory, address)\n    {\n        uint256 length = A.length;\n        require(index < A.length, \"Index must be < A length\");\n        address[] memory newAddresses = new address[](length - 1);\n        for (uint256 i = 0; i < index; i++) {\n            newAddresses[i] = A[i];\n        }\n        for (uint256 j = index + 1; j < length; j++) {\n            newAddresses[j - 1] = A[j];\n        }\n        return (newAddresses, A[index]);\n    }\n}\n"
    },
    "contracts/lib/Bytes32ArrayUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\n/**\n * @title Bytes32ArrayUtils\n * @author Arx Research\n *\n * Fork of Set Protocol's AddressArrayUtils library adapted for usage with bytes32 arrays.\n */\nlibrary Bytes32ArrayUtils {\n\n    uint256 constant internal MAX_INT = 2**256 - 1;\n\n    /**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(bytes32[] memory A, bytes32 a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (MAX_INT, false);\n    }\n\n    /**\n    * Returns true if the value is present in the list. Uses indexOf internally.\n    * @param A The input array to search\n    * @param a The value to find\n    * @return Returns isIn for the first occurrence starting from index 0\n    */\n    function contains(bytes32[] memory A, bytes32 a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n    * Returns true if there are 2 elements that are the same in an array\n    * @param A The input array to search\n    * @return Returns boolean for the first occurrence of a duplicate\n    */\n    function hasDuplicate(bytes32[] memory A) internal pure returns(bool) {\n        require(A.length > 0, \"A is empty\");\n\n        for (uint256 i = 0; i < A.length - 1; i++) {\n            bytes32 current = A[i];\n            for (uint256 j = i + 1; j < A.length; j++) {\n                if (current == A[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The bytes32 to remove\n     * @return Returns the array with the object removed.\n     */\n    function remove(bytes32[] memory A, bytes32 a)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"bytes32 not in array.\");\n        } else {\n            (bytes32[] memory _A,) = pop(A, index);\n            return _A;\n        }\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The bytes32 to remove\n     */\n    function removeStorage(bytes32[] storage A, bytes32 a)\n        internal\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"bytes32 not in array.\");\n        } else {\n            uint256 lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\n            if (index != lastIndex) { A[index] = A[lastIndex]; }\n            A.pop();\n        }\n    }\n\n    /**\n    * Removes specified index from array\n    * @param A The input array to search\n    * @param index The index to remove\n    * @return Returns the new array and the removed entry\n    */\n    function pop(bytes32[] memory A, uint256 index)\n        internal\n        pure\n        returns (bytes32[] memory, bytes32)\n    {\n        uint256 length = A.length;\n        require(index < A.length, \"Index must be < A length\");\n        bytes32[] memory newBytes = new bytes32[](length - 1);\n        for (uint256 i = 0; i < index; i++) {\n            newBytes[i] = A[i];\n        }\n        for (uint256 j = index + 1; j < length; j++) {\n            newBytes[j - 1] = A[j];\n        }\n        return (newBytes, A[index]);\n    }\n}\n"
    },
    "contracts/lib/ChipValidations.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\nlibrary ChipValidations {\n    using SignatureChecker for address;\n    using ECDSA for bytes;\n\n    function validateSignatureAndExpiration(\n        address _chipId,\n        uint256 _commitBlock,\n        uint256 _maxBlockWindow,\n        bytes memory _payload,\n        bytes memory _signature\n    )\n        internal\n        view\n    {\n        require(_chipId.isValidSignatureNow(_payload.toEthSignedMessageHash(), _signature), \"Invalid signature\");\n\n        // Check that the signature was generated within the maxBlockWindow\n        require(block.number <= _commitBlock + _maxBlockWindow, \"Signature expired\");\n    }\n}\n"
    },
    "contracts/lib/StringArrayUtils.sol": {
      "content": "/*\n    Copyright 2021 Set Labs Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n    SPDX-License-Identifier: Apache-2.0\n*/\n\npragma solidity ^0.8.17;\n\n/**\n * @title StringArrayUtils\n * @author Set Protocol\n *\n * Utility functions to handle String Arrays\n */\nlibrary StringArrayUtils {\n\n    uint256 constant internal MAX_INT = 2**256 - 1;\n\n    /**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input string to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(string[] memory A, string memory a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (keccak256(bytes(A[i])) == keccak256(bytes(a))) {\n                return (i, true);\n            }\n        }\n        return (MAX_INT, false);\n    }\n\n    /**\n    * Returns true if the value is present in the list. Uses indexOf internally.\n    * @param A The input array to search\n    * @param a The value to find\n    * @return Returns isIn for the first occurrence starting from index 0\n    */\n    function contains(string[] memory A, string memory a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The string to remove\n     */\n    function removeStorage(string[] storage A, string memory a)\n        internal\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"String not in array.\");\n        } else {\n            uint256 lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\n            if (index != lastIndex) { A[index] = A[lastIndex]; }\n            A.pop();\n        }\n    }\n}\n"
    },
    "contracts/ManufacturerRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title ManufacturerRegistry\n * @author Arx\n *\n * @notice Registry for tracking and maintaining relevant info for Manufacturers. In order to make chips valid for the\n * protocol, manufacturers must register their chips in enrollments. Each enrollment will be assigned an id, which\n * must be referenced when adding chips to the registry. Enrollments have a merkle root of all chipIds (addresses)\n * that are valid for the enrollment. Manufacturer's can be found in three states:\n * 1. Unregistered: manufacturers[_manufacturerId].registered = false. This is the default state for all manufacturers.\n * 2. Registered: manufacturers[_manufacturerId].registered = true && manufacturers[_manufacturerId].owner != address(0).\n * 3. Read-only: manufacturers[_manufacturerId].registered = true && manufacturers[_manufacturerId].owner == address(0).\n *    Once a manufacturerId has been put in this state it CANNOT leave it.\n */\ncontract ManufacturerRegistry is Ownable {\n    \n    /* ============ Events ============ */\n    event ManufacturerAdded(                // Called in addManufacturer\n        bytes32 indexed manufacturerId,\n        address owner\n    );\n    event ManufacturerRemoved(              // Called in removeManufacturer\n        bytes32 indexed manufacturerId\n    );\n\n    event EnrollmentAdded(                  // Called in addChipEnrollment\n        bytes32 indexed manufacturerId,     // Manufacturer identifier\n        bytes32 indexed enrollmentId,       // Enrollment identifier\n        bytes32 merkleRoot,                 // Merkle root of all chipIds (addresses) that are valid for this enrollment\n        address manufacturerCertSigner,     // Address of certificate signer for this enrollment\n        address authModel,                  // Address of contract that implements example signature validation for a chip\n        string chipValidationDataUri,       // URI pointing to location of off-chain data required to validate chip is part of manufacturer enrollment\n        string bootloaderApp,               // Bootloader app for this enrollment\n        string chipModel                    // Chip model for this enrollment\n    );\n\n    event ManufacturerOwnerUpdated(         // Called in updateManufacturerOwner\n        bytes32 indexed manufacturerId,\n        address newOwner\n    );\n\n    /* ============ Structs ============ */\n    struct EnrollmentInfo {\n        uint256 manufacturerId;\n        bytes32 merkleRoot;\n        address manufacturerCertSigner;\n        address authModel;                  // Address with implementation for validating chip signatures\n        string chipValidationDataUri;       // URI pointing to location of off-chain data required to validate chip is part of manufacturer enrollment\n        string bootloaderApp;\n        string chipModel;                   // Description of chip\n    }\n\n    struct ManufacturerInfo {\n        address owner;                      // Address that has ability to add enrollments for this manufacturer; turning off access is done by\n                                            // setting owner to 0 address\n        bool registered;                    // If manufacturer is registered, manufacturers cannot be unregistered in order to keep history,\n                                            // burn access by setting owner to 0 address\n        bytes32[] enrollments;\n        uint256 nonce;                      // Nonce for manufacturer, incremented after each new enrollment by manufacturer\n    }\n\n    /* ============ Modifiers ============ */\n    modifier onlyManufacturer(bytes32 _manufacturerId) {\n        require(manufacturers[_manufacturerId].owner == msg.sender, \"Only manufacturer can call this function\");\n        _;\n    }\n\n    /* ============ State Variables ============ */\n    mapping(bytes32 => EnrollmentInfo) internal enrollments;\n    mapping(bytes32 => ManufacturerInfo) internal manufacturers;\n    \n    /* ============ Constructor ============ */\n    /**\n     * @dev Constructor for ManufacturerRegistry. Sets owner to governance address.\n     *\n     * @param _governance               Address of governance\n     */\n    constructor(address _governance) Ownable() {\n        transferOwnership(_governance);\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @dev ONLY MANUFACTURER: Adds a new enrollment for an active manufacturer. Enrollment is assigned an id which is returned. Only owner address\n     * associated with _manufacturerId can call this function. An \"active\" manufacturer is one with registered=true and a non-zero owner address.\n     *\n     * @param _manufacturerId               Bytes32 identifier for manufacturer (i.e. could be hash of manufacturer name)\n     * @param _merkleRoot                   Merkle root of all chipIds (addresses) that are valid for this enrollment\n     * @param _certSigner                   Address of certificate signer for this enrollment\n     * @param _authModel                    Address of contract that implements example signature validation for a chip\n     * @param _chipValidationDataUri        URI pointing to location of off-chain data required to validate chip is part of manufacturer enrollment\n     * @param _bootloaderApp                Bootloader app for this enrollment\n     * @param _chipModel                    Chip model for this enrollment\n     * @return enrollmentId                 Id of enrollment\n     */\n    function addChipEnrollment(\n        bytes32 _manufacturerId,\n        bytes32 _merkleRoot,\n        address _certSigner,\n        address _authModel,\n        string calldata _chipValidationDataUri,\n        string calldata _bootloaderApp,\n        string calldata _chipModel\n    ) \n        external\n        onlyManufacturer(_manufacturerId)\n        returns (bytes32 enrollmentId)\n    {\n        require(_certSigner != address(0), \"Invalid certificate signer address\");\n        require(_authModel != address(0), \"Invalid auth model address\");\n\n        enrollmentId = keccak256(abi.encodePacked(_manufacturerId, manufacturers[_manufacturerId].nonce));\n\n        enrollments[enrollmentId] = EnrollmentInfo({\n            manufacturerId: uint256(_manufacturerId),\n            merkleRoot: _merkleRoot,\n            manufacturerCertSigner: _certSigner,\n            authModel: _authModel,\n            chipValidationDataUri: _chipValidationDataUri,\n            bootloaderApp: _bootloaderApp,\n            chipModel: _chipModel\n        });\n\n        manufacturers[_manufacturerId].enrollments.push(enrollmentId);\n        manufacturers[_manufacturerId].nonce++;\n\n        emit EnrollmentAdded(\n            _manufacturerId,\n            enrollmentId,\n            _merkleRoot,\n            _certSigner,\n            _authModel,\n            _chipValidationDataUri,\n            _bootloaderApp,\n            _chipModel\n        );\n    }\n\n    /**\n     * @dev ONLY OWNER: Registers a new manufacturer. Manufacturer is marked as registered forever once added so that history can't be mixed with\n     * other manufacturers. To burn access the owner param is set to the zero address (in removeManufacturer). A manufacturer is considered \"new\"\n     * if registered=false.\n     *\n     * @param _manufacturerId           Bytes32 identifier for manufacturer (i.e. could be hash of manufacturer name)\n     * @param _owner                    Address of Perp Vault contract\n     */\n    function addManufacturer(bytes32 _manufacturerId, address _owner) external onlyOwner {\n        require(!manufacturers[_manufacturerId].registered, \"Manufacturer already registered\");\n        require(_owner != address(0), \"Invalid owner address\");\n\n        manufacturers[_manufacturerId].owner = _owner;\n        manufacturers[_manufacturerId].registered = true;\n\n        emit ManufacturerAdded(_manufacturerId, _owner);\n    }\n\n    /**\n     * @dev ONLY OWNER: Removes an active manufacturer putting their history in read-only mode. In order to remove access we burn the owner key,\n     * this prevents history from being mixed in case a new manufacturer accidentally wants to use an old ID (it would revert and they would\n     * need to choose an new ID).\n     *\n     * @param _manufacturerId           Bytes32 identifier for manufacturer (i.e. could be hash of manufacturer name)\n     */\n    function removeManufacturer(bytes32 _manufacturerId) external onlyOwner {\n        require(manufacturers[_manufacturerId].owner != address(0), \"Manufacturer not registered\");\n\n        // We don't change registered to false in order to make sure that the manufacturer name is not reused, thus mixing history\n        delete manufacturers[_manufacturerId].owner;\n\n        emit ManufacturerRemoved(_manufacturerId);\n    }\n\n    /**\n     * @dev ONLY MANUFACTURER: Updates the owner address for a manufacturer. Only owner address associated with _manufacturerId can call this\n     * function.\n     *\n     * @param _manufacturerId           Bytes32 identifier for manufacturer (i.e. could be hash of manufacturer name)\n     * @param _newOwner                 Address of new owner\n     */\n    function updateManufacturerOwner(bytes32 _manufacturerId, address _newOwner) external onlyManufacturer(_manufacturerId) {\n        require(_newOwner != address(0), \"Invalid owner address\");\n\n        manufacturers[_manufacturerId].owner = _newOwner;\n        emit ManufacturerOwnerUpdated(_manufacturerId, _newOwner);\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     @dev Validate that _chipId is included in the merkle tree for _enrollmentId.\n\n     * @param _enrollmentId         bytes32 identifier of the manaufacturer enrollment\n     * @param _index                Index of enrollment in the merkle tree\n     * @param _chipId               Public key associated with the chip\n     * @param _merkleProof          Merkle Proof for _chipId's inclusion in _enrollmentId\n     */\n    function isEnrolledChip(\n        bytes32 _enrollmentId,\n        uint256 _index,\n        address _chipId,\n        bytes32[] calldata _merkleProof\n    )\n        external\n        view\n        returns (bool)\n    {\n        bytes32 enrollmentMerkleRoot = enrollments[_enrollmentId].merkleRoot;\n        bytes32 node = keccak256(bytes.concat(keccak256(abi.encode(_index, _chipId))));\n\n        return MerkleProof.verify(_merkleProof, enrollmentMerkleRoot, node);\n    }\n\n    function getManufacturerInfo(bytes32 _manufacturerId) external view returns (ManufacturerInfo memory) {\n        return manufacturers[_manufacturerId];\n    }\n\n    function getEnrollmentInfo(bytes32 _enrollmentId) public view returns (EnrollmentInfo memory) {\n        return enrollments[_enrollmentId];\n    }\n\n    function getEnrollmentBootloaderApp(bytes32 _enrollmentId) external view returns (string memory) {\n        return getEnrollmentInfo(_enrollmentId).bootloaderApp;\n    }\n}\n"
    },
    "contracts/mocks/AccountMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { IERC1271 } from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport { IERC721Receiver } from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nimport { IPBT } from \"../token/IPBT.sol\";\n\ncontract AccountMock is IERC1271 {\n\n    using ECDSA for bytes32;\n\n    bytes4 public constant MAGIC_VALUE = 0x1626ba7e;\n\n    address public publicKey;\n    IPBT public chipRegistry;\n\n    constructor(address _publicKey, address _chipRegistry) {\n        publicKey = _publicKey;\n        chipRegistry = IPBT(_chipRegistry);\n    }\n\n    function transferTokenWithChip(\n        bytes calldata signatureFromChip,\n        uint256 blockNumberUsedInSig,\n        bool useSafeTransferFrom\n    )\n        external\n    {\n        chipRegistry.transferTokenWithChip(signatureFromChip, blockNumberUsedInSig, useSafeTransferFrom);\n    }\n\n    function transferToken(\n        address chipId,\n        bytes calldata signatureFromChip,\n        uint256 blockNumberUsedInSig,\n        bool useSafeTransferFrom,\n        bytes calldata payload\n    )\n        external\n    {\n        chipRegistry.transferToken(chipId, signatureFromChip, blockNumberUsedInSig, useSafeTransferFrom, payload);\n    }\n\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external view override returns (bytes4) {\n        if (_hash.recover(_signature) == publicKey) {\n            return MAGIC_VALUE;\n        } else {\n            return 0xffffffff;\n        }\n    }\n\n    function onERC721Received(\n        address /*operator*/,\n        address /*from*/,\n        uint256 /*tokenId*/,\n        bytes calldata /*data*/\n    ) external pure returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/mocks/ChipRegistryMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { ChipRegistry } from \"../ChipRegistry.sol\";\nimport { ClaimedPBT } from \"../token/ClaimedPBT.sol\";\nimport { IChipRegistry } from \"../interfaces/IChipRegistry.sol\";\nimport { IManufacturerRegistry } from \"../interfaces/IManufacturerRegistry.sol\";\nimport { ITransferPolicy } from \"../interfaces/ITransferPolicy.sol\";\n\ncontract ChipRegistryMock is ChipRegistry {\n    mapping(address=>bool) public chipIds;\n    mapping(bytes=>bool) public developerInclusionProofs;\n    mapping(bytes=>bool) public developerCustodyProofs;\n    \n    constructor(\n        IManufacturerRegistry _manufacturerRegistry,\n        string[] memory _gatewayUrls,\n        uint256 _maxBlockWindow,\n        uint256 _maxLockinPeriod\n    )\n        ChipRegistry(_manufacturerRegistry, _gatewayUrls, _maxBlockWindow, _maxLockinPeriod)\n    {}\n\n    function claimChip(\n        address _chipId,\n        IChipRegistry.ChipClaim calldata /*_chipClaim*/,\n        IChipRegistry.ManufacturerValidation memory /*_manufacturerValidation*/,\n        bytes calldata _developerInclusionProof,\n        bytes calldata _developerCustodyProof\n    ) external override {\n        chipIds[_chipId] = true;\n        developerInclusionProofs[_developerInclusionProof] = true;\n        developerCustodyProofs[_developerCustodyProof] = true;\n    }\n\n    function mockClaimChip(address _chipId, address _owner) external {\n        ChipInfo memory chipInfo = ChipInfo({\n            tokenId: 0,     // temporary value, will be set in _mint\n            transferPolicy: ITransferPolicy(address(0)),\n            tokenUri: \"\",\n            tokenData: \"\"\n        });\n        ClaimedPBT._mint(_owner, _chipId, chipInfo);\n    }\n\n    function setInitialService(address _chipId, bytes32 _serviceId, uint256 _timelock) external {\n        servicesRegistry.setInitialService(_chipId, _serviceId, _timelock);\n    }\n}\n"
    },
    "contracts/mocks/ChipValidationsMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { ChipValidations } from \"../lib/ChipValidations.sol\";\n\ncontract ChipValidationsMock {\n\n    constructor() {}\n\n    function validateSignatureAndExpiration(\n        address _chipId,\n        uint256 _commitBlock,\n        uint256 _maxBlockWindow,\n        bytes memory _payload,\n        bytes memory _signature\n    )\n        external\n        view\n    {\n        ChipValidations.validateSignatureAndExpiration(\n            _chipId,\n            _commitBlock,\n            _maxBlockWindow,\n            _payload,\n            _signature\n        );\n    }\n}\n"
    },
    "contracts/mocks/ClaimedPBTMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { ClaimedPBT } from \"../token/ClaimedPBT.sol\";\n\ncontract ClaimedPBTMock is ClaimedPBT {\n\n    constructor(string memory _name, string memory _symbol, uint256 maxBlockWindow) \n        ClaimedPBT(_name, _symbol, maxBlockWindow)\n    {}\n\n    function testMint(\n        address _to,\n        address _chipId,\n        ChipInfo memory  _chipInfo\n    ) external {\n        _mint(_to, _chipId, _chipInfo);\n    }\n}\n"
    },
    "contracts/mocks/DeveloperRegistryMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { DeveloperRegistry } from \"../DeveloperRegistry.sol\";\nimport { IERS } from \"../interfaces/IERS.sol\";\n\ncontract DeveloperRegistryMock is DeveloperRegistry {\n\n    constructor(address _governance) \n        DeveloperRegistry(_governance)\n    {}\n\n    function addMockRegistrar(address _newRegistrar, bytes32 _nameHash) external {\n        ersRegistry.createSubnodeRecord(ROOT_NODE, _nameHash, _newRegistrar, _newRegistrar);\n        \n        isDeveloperRegistrar[_newRegistrar] = true;\n        developerRegistrars.push(_newRegistrar);\n    }\n}\n"
    },
    "contracts/mocks/InterfaceIdGetterMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport { IChipRegistry } from \"../interfaces/IChipRegistry.sol\";\nimport { IPBT } from \"../token/IPBT.sol\";\n\ncontract InterfaceIdGetterMock {\n    constructor() {}\n\n    function getERC165InterfaceId() external pure returns (bytes4) {\n        return type(IERC165).interfaceId;\n    }\n\n    function getERC721InterfaceId() external pure returns (bytes4) {\n        return type(IERC721).interfaceId;\n    }\n\n    function getERC721MetadataInterfaceId() external pure returns (bytes4) {\n        return type(IERC721Metadata).interfaceId;\n    }\n\n    function getPBTInterfaceId() external pure returns (bytes4) {\n        return type(IPBT).interfaceId;\n    }\n\n    function getChipRegistryInterfaceId() external pure returns (bytes4) {\n        return type(IChipRegistry).interfaceId;\n    }\n}\n"
    },
    "contracts/mocks/ProjectRegistrarMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { IChipRegistry } from \"../interfaces/IChipRegistry.sol\";\nimport { IERS } from \"../interfaces/IERS.sol\";\n\ncontract ProjectRegistrarMock {\n    \n    IChipRegistry public immutable chipRegistry;\n    IERS public immutable ers;\n\n    bytes32 public rootNode;\n\n    constructor(IChipRegistry _chipRegistry, IERS _ers) {\n        chipRegistry = _chipRegistry;\n        ers = _ers;\n    }\n    \n    function setRootNode(\n        bytes32 _rootNode\n    )\n        external\n    {\n        rootNode = _rootNode;\n    }\n\n    function claimChip(\n        bytes32 _nameHash,\n        address chipOwner,\n        IChipRegistry.DeveloperMerkleInfo calldata _claimData,\n        IChipRegistry.ManufacturerValidation calldata _manufacturerValidation,\n        bytes calldata _developerInclusionProof,\n        bytes calldata _signedCert\n    )\n        external\n    {\n        // NOTE: Don't use in prod. We are passing in the \"label\" in the ChipClaim struct then over-writing for\n        // testing convenience.\n        bytes32 chipErsNode = ers.createSubnodeRecord(\n            rootNode,\n            _nameHash,\n            chipOwner,\n            msg.sender\n        );\n\n        IChipRegistry.ChipClaim memory chipClaim = IChipRegistry.ChipClaim({\n            owner: chipOwner,\n            ersNode: chipErsNode,\n            developerMerkleInfo: _claimData\n        });\n\n        chipRegistry.claimChip(\n            msg.sender,\n            chipClaim,\n            _manufacturerValidation,\n            _developerInclusionProof,\n            _signedCert\n        );\n    }\n}\n"
    },
    "contracts/mocks/TransferPolicyMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { ITransferPolicy } from \"../interfaces/ITransferPolicy.sol\";\n\ncontract TransferPolicyMock is ITransferPolicy {\n\n    struct CallInfo {\n        address chipId;\n        address sender;\n        address chipOwner;\n        bytes payload;\n        bytes signature;\n    }\n\n    CallInfo public callInfo;\n    /* ============ Constructor ============ */\n\n    constructor() {}\n    \n    /* ============ External Functions ============ */\n\n    function authorizeTransfer(\n        address _chipId,\n        address _sender,\n        address _chipOwner,\n        bytes calldata _payload,\n        bytes calldata _signature\n    )\n        external\n        override\n    {\n        callInfo = CallInfo({\n            chipId: _chipId,\n            sender: _sender,\n            chipOwner: _chipOwner,\n            payload: _payload,\n            signature: _signature\n        });\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/project-registrars/AuthenticityProjectRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { BaseProjectRegistrar } from \"./BaseProjectRegistrar.sol\";\nimport { ChipValidations } from \"../lib/ChipValidations.sol\";\nimport { IChipRegistry } from \"../interfaces/IChipRegistry.sol\";\nimport { IERS } from \"../interfaces/IERS.sol\";\nimport { IDeveloperRegistrar } from \"../interfaces/IDeveloperRegistrar.sol\";\n\n/**\n * @title AuthenticityProjectRegistrar\n * @author Arx Research\n * \n * @notice Entry point for users claiming chips. Responsible for setting the ers name for each chip in its enrollment as [chip].project.developer.ers.\n * The Developer Registrar sets the root node of the ProjectRegistrar when addProject is called on the DeveloperRegistrar. This regostrar should be\n * used by projects that care about tracking the full chain of custody of their chips via ERSRegistry. If project only wants to use the protocol for\n * chip URL redirects other ProjectRegistrars may be a better fit.\n */\ncontract AuthenticityProjectRegistrar is BaseProjectRegistrar {\n    using ChipValidations for address;\n\n    /* ============ State Variables ============ */\n    uint256 public immutable maxBlockWindow;\n\n    /* ============ Constructor ============ */\n    /**\n     * @param _projectManager           The address that will be set as the owner\n     * @param _chipRegistry             The chip registry of the ERS system being used\n     * @param _ers                      The ERS registry of the ERS system being used\n     * @param _developerRegistrar       The DeveloperRegistrar that made this project\n     * @param _maxBlockWindow           The maximum amount of blocks a signature used for updating chip table is valid for\n     */\n    constructor(\n        address _projectManager, \n        IChipRegistry _chipRegistry, \n        IERS _ers, \n        IDeveloperRegistrar _developerRegistrar,\n        uint256 _maxBlockWindow\n    ) \n        BaseProjectRegistrar(\n            _projectManager,\n            _chipRegistry,\n            _ers,\n            _developerRegistrar\n        )\n    {\n        maxBlockWindow = _maxBlockWindow;\n    }\n\n    /* ============ External Functions ============ */\n    /**\n     * @notice Allow a chip holder to name chip to the ERS and enroll it to the Chip Registry. Chip owner will be\n     * set as the msg.sender. Will revert if invalid proof of ownership is given or ownership proof is expired.\n     * Will revert if chip is msg.sender since it cannot own itself.\n     * \n     * @param _chipId                   Address of the chip being claimed\n     * @param _nameHash                 Keccak256 hash of the human-readable name for the chip being claimed\n     * @param _claimData                Struct containing chip info\n     * @param _manufacturerValidation   Struct with needed info for chip's manufacturer validation\n     * @param _commitBlock              The block the signature is tied to (used to put a time limit on the signature)\n     * @param _chipOwnershipProof       Chip signature of the chainId, _commitBlock, _nameHash, and msg.sender packed together\n     * @param _developerInclusionProof  Chip's public key/ID signed by the projectPublicKey, indicates Developer approves chip as part of project\n     * @param _developerCustodyProof    Proof that the chip was in custody of the Developer, the projectPublicKey signed by the chip\n     */\n    function claimChip(\n        address _chipId,\n        bytes32 _nameHash,\n        IChipRegistry.DeveloperMerkleInfo memory _claimData,\n        IChipRegistry.ManufacturerValidation memory _manufacturerValidation,\n        uint256 _commitBlock,\n        bytes memory _chipOwnershipProof,\n        bytes memory _developerInclusionProof,\n        bytes memory _developerCustodyProof\n    ) \n        external \n    {\n        require(msg.sender != _chipId, \"Chip cannot own itself\");\n\n        address chipOwner = msg.sender;\n\n        _chipId.validateSignatureAndExpiration(\n            _commitBlock,\n            maxBlockWindow,\n            abi.encodePacked(block.chainid, _commitBlock, _nameHash, chipOwner), \n            _chipOwnershipProof\n        );\n\n        // Call createSubnodeRecord from the ERS Registry to create a subnode with the chip as the resolver\n        // and the caller as the owner.\n        _createSubnodeAndClaimChip(\n            _chipId,\n            _nameHash,\n            chipOwner,\n            _claimData,\n            _manufacturerValidation,\n            _developerInclusionProof,\n            _developerCustodyProof\n        );\n    }\n}\n\n\n\n"
    },
    "contracts/project-registrars/BaseProjectRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { ChipValidations } from \"../lib/ChipValidations.sol\";\nimport { IChipRegistry } from \"../interfaces/IChipRegistry.sol\";\nimport { IERS } from \"../interfaces/IERS.sol\";\nimport { IProjectRegistrar } from \"../interfaces/IProjectRegistrar.sol\";\nimport { IDeveloperRegistrar } from \"../interfaces/IDeveloperRegistrar.sol\";\n\n/**\n * @title BaseProjectRegistrar\n * @author Arx Research\n * \n * @notice Base contract for ProjectRegistrars. Contains common functionality for all ProjectRegistrars including setting the root node\n * and claiming chips.\n */\ncontract BaseProjectRegistrar is Ownable, IProjectRegistrar {\n    using ChipValidations for address;\n\n    /* ============ Events ============ */\n    // Emitted when a new root node has been set\n    event RootNodeSet(bytes32 _rootNode);\n\n    /* ============ Modifiers ============ */\n    modifier onlyDeveloperRegistrar() {\n        require(address(developerRegistrar) == msg.sender, \"onlyDeveloperRegistrar: Only the contract's Developer Registrar can call this function\");\n        _;\n    }\n\n    /* ============ State Variables ============ */\n    IChipRegistry public immutable chipRegistry; \n    IERS public immutable ers; \n    IDeveloperRegistrar public immutable developerRegistrar; \n    \n    bytes32 public rootNode;                    // It is the hash(hash(projectName), node(developer.ers))\n\n    /* ============ Constructor ============ */\n    /**\n     * @param _projectManager           The address that will be set as the owner\n     * @param _chipRegistry             The chip registry of the ERS system being used\n     * @param _ers                      The ERS registry of the ERS system being used\n     * @param _developerRegistrar       The DeveloperRegistrar that made this project\n     */\n    constructor(\n        address _projectManager, \n        IChipRegistry _chipRegistry, \n        IERS _ers, \n        IDeveloperRegistrar _developerRegistrar\n    ) \n        Ownable() \n    {\n        _transferOwnership(_projectManager);\n        chipRegistry = _chipRegistry;\n        ers = _ers;\n        developerRegistrar = _developerRegistrar;\n    }\n\n    /* ============ External Admin Functions ============ */\n\n    /**\n     * @dev ONLY DEVELOPER REGISTRAR: Set the root node for this project (ie project.developer.ers)\n     * \n     * @param _rootNode The root node for this project\n     */\n    function setRootNode(bytes32 _rootNode) onlyDeveloperRegistrar() external override {\n        require(rootNode == bytes32(0), \"Root node already set\");\n        rootNode = _rootNode;\n        emit RootNodeSet(_rootNode);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Allow a chip holder to name chip to the ERS and enroll it to the Chip Registry. Chip owner will be\n     * set as the msg.sender. Will revert if invalid proof of ownership is given or ownership proof is expired.\n     * Will revert if chip is msg.sender since it cannot own itself.\n     * \n     * @param _chipId                   Address of the chip being claimed\n     * @param _nameHash                 Keccak256 hash of the human-readable name for the chip being claimed\n     * @param _chipOwner                Intended owner of the chip being claimed\n     * @param _claimData                Struct containing chip info\n     * @param _manufacturerValidation   Struct with needed info for chip's manufacturer validation\n     * @param _developerInclusionProof  Chip's public key/ID signed by the projectPublicKey, indicates Developer approves chip as part of project\n     * @param _developerCustodyProof    Proof that the chip was in custody of the Developer, the projectPublicKey signed by the chip\n     */\n    function _createSubnodeAndClaimChip(\n        address _chipId,\n        bytes32 _nameHash,\n        address _chipOwner,\n        IChipRegistry.DeveloperMerkleInfo memory _claimData,\n        IChipRegistry.ManufacturerValidation memory _manufacturerValidation,\n        bytes memory _developerInclusionProof,\n        bytes memory _developerCustodyProof\n    ) \n        internal\n    {\n        // Call createSubnodeRecord from the ERS Registry to create a subnode with the chip as the resolver\n        // and the caller as the owner.\n        bytes32 ersNode = ers.createSubnodeRecord(rootNode, _nameHash, _chipOwner, _chipId);\n\n        IChipRegistry.ChipClaim memory chipClaim = IChipRegistry.ChipClaim({\n            owner: _chipOwner,\n            ersNode: ersNode,\n            developerMerkleInfo: _claimData\n        });\n\n        // Registrar calls the claimChip function on the ChipRegistry\n        chipRegistry.claimChip(_chipId, chipClaim, _manufacturerValidation, _developerInclusionProof, _developerCustodyProof);\n    }\n}\n\n\n\n"
    },
    "contracts/project-registrars/RedirectProjectRegistrar.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { BaseProjectRegistrar } from \"./BaseProjectRegistrar.sol\";\nimport { ChipValidations } from \"../lib/ChipValidations.sol\";\nimport { IChipRegistry } from \"../interfaces/IChipRegistry.sol\";\nimport { IERS } from \"../interfaces/IERS.sol\";\nimport { IDeveloperRegistrar } from \"../interfaces/IDeveloperRegistrar.sol\";\n\n/**\n * @title RedirectProjectRegistrar\n * @author Arx Research\n * \n * @notice Entry point to claim chips for projects that only want to use the protocol for chip URL redirects and verification of\n * manufacturing by a trusted party. Chip claims can only be performed by the project manager. This registrar should be used by\n * projects that do not care about tracking the full chain of custody of their chips via ERSRegistry.\n */\ncontract RedirectProjectRegistrar is BaseProjectRegistrar {\n    using ChipValidations for address;\n\n    /* ============ Structs ============ */\n    struct ProjectChipClaim {\n        address chipId;\n        bytes32 chipNameHash;\n        IChipRegistry.DeveloperMerkleInfo developerMerkleInfo;\n        IChipRegistry.ManufacturerValidation manufacturerValidation;\n        bytes developerInclusionProof;\n        bytes developerCustodyProof;\n    }\n\n    /* ============ Constructor ============ */\n    /**\n     * @param _projectManager           The address that will be set as the owner\n     * @param _chipRegistry             The chip registry of the ERS system being used\n     * @param _ers                      The ERS registry of the ERS system being used\n     * @param _developerRegistrar       The DeveloperRegistrar that made this project\n     */\n    constructor(\n        address _projectManager, \n        IChipRegistry _chipRegistry, \n        IERS _ers, \n        IDeveloperRegistrar _developerRegistrar\n    ) \n        BaseProjectRegistrar(\n            _projectManager,\n            _chipRegistry,\n            _ers,\n            _developerRegistrar\n        )\n    {}\n\n    /* ============ External Functions ============ */\n    /**\n     * @notice ONLY OWNER: Allow the project manager to claim chips for the project. Intended to be used for chips\n     * that are meant to be redirected to a URL and not concerned with tracking the full chain of custody. This\n     * gives managers to ability to maintain ownership over the chips (and thus the primaryService) for as long\n     * as they want.\n     * \n     * @param _claimData    Array of information needed for claiming chips\n     */\n    function claimChips(\n        ProjectChipClaim[] calldata _claimData\n    ) \n        external\n        onlyOwner()\n    {\n        for (uint256 i = 0; i < _claimData.length; i++) {\n            ProjectChipClaim memory claim = _claimData[i];\n            _createSubnodeAndClaimChip(\n                claim.chipId,\n                claim.chipNameHash,\n                msg.sender,\n                claim.developerMerkleInfo,\n                claim.manufacturerValidation,\n                claim.developerInclusionProof,\n                claim.developerCustodyProof\n            );\n        }\n    }\n}\n\n\n\n"
    },
    "contracts/ServicesRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport { Bytes32ArrayUtils } from \"./lib/Bytes32ArrayUtils.sol\"; \nimport { ChipValidations } from \"./lib/ChipValidations.sol\";\nimport { IChipRegistry } from \"./interfaces/IChipRegistry.sol\";\nimport { IServicesRegistry } from \"./interfaces/IServicesRegistry.sol\";\n\n/**\n * @title ServicesRegistry\n * @author Arx Research\n *\n * @notice Contract for creating and updating services for service owners and adding/removing services for chip owners. Services\n * contain a recordType and record content. The recordType is intended to be a standardized off-chain string that clients\n * can use to interpret the record content. Record types could be a tokenUri, a URL, a smart contract, or any other value.\n * Chips are always enrolled in a primary service, in most cases this is the service the chip should resolve to when\n * scanned. Additionally, a chip can be enrolled in secondary services that allow it to access additional functionality.\n * Primary services have a timelock that must expire before the primary service can be changed. Secondary services can be\n * added and removed at any time. The primary service cannot be one of the chip's secondary services.\n */\ncontract ServicesRegistry is IServicesRegistry {\n    using Bytes32ArrayUtils for bytes32[];\n    using ChipValidations for address;\n    using ECDSA for bytes;\n\n    /* ============ Events ============ */\n\n    event ServiceCreated(bytes32 indexed serviceId, address indexed owner);\n    event ServiceRecordAdded(bytes32 indexed serviceId, bytes32 indexed recordType, bytes content, bool appendId);\n    event ServiceRecordEdited(bytes32 indexed serviceId, bytes32 indexed recordType, bytes newContent, bool appendId);\n    event ServiceRecordRemoved(bytes32 indexed serviceId, bytes32 indexed recordType);\n    event ServiceOwnershipTransferred(bytes32 indexed serviceId, address oldOwner, address newOwner);\n\n    event PrimaryServiceUpdated(\n        address indexed chipId,\n        bytes32 indexed newPrimaryService,\n        bytes32 oldPrimaryService,\n        uint256 serviceTimelock\n    );\n    event SecondaryServiceAdded(address indexed chipId, bytes32 indexed serviceId);\n    event SecondaryServiceRemoved(address indexed chipId, bytes32 indexed serviceId);\n\n    /* ============ Structs ============ */\n\n    struct RecordContent {\n        bool enabled;                   // Need to have an enabled flag because we can't rely on the content field containing info\n        bool appendId;                  // Indicates whether _chipId should be appended to end of the record content\n        bytes content;\n    }\n\n    struct ServiceRecord {\n        bytes32 recordType;\n        bytes content;\n        bool appendId;                  // Indicates whether _chipId should be appended to end of the record content\n    }\n\n    struct ServiceInfo {\n        address owner;\n        bytes32[] recordTypes;\n    }\n\n    struct ChipServices {\n        bytes32 primaryService;\n        uint256 serviceTimelock;        // Timelock before which the primaryService cannot be changed\n        bytes32[] secondaryServices;\n    }\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyServiceOwner(bytes32 _serviceId) {\n        require(serviceInfo[_serviceId].owner == msg.sender, \"Caller must be service owner\");\n        _;\n    }\n\n    modifier onlyChipOwner(address _chipId) {\n        require(chipRegistry.ownerOf(_chipId) == msg.sender, \"Caller must be chip owner\");\n        _;\n    }\n\n    /* ============ State Variables ============ */\n\n    IChipRegistry public immutable chipRegistry;\n    uint256 public immutable maxBlockWindow;\n\n    mapping(address=>ChipServices) public chipServices;\n    mapping(address=>mapping(bytes32=>bool)) public enrolledServices;\n    mapping(bytes32=>ServiceInfo) public serviceInfo;\n    mapping(bytes32=>mapping(bytes32=>RecordContent)) public serviceRecords;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @notice Constructor for ServicesRegistry\n     *\n     * @param _chipRegistry         Address of the ChipRegistry contract\n     * @param _maxBlockWindow       The maximum amount of blocks a signature used for updating chip table is valid for\n    */\n    constructor(IChipRegistry _chipRegistry, uint256 _maxBlockWindow) {\n        chipRegistry = _chipRegistry;\n        maxBlockWindow = _maxBlockWindow;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice Creates a new service. Services contain multiple different record types which could be a tokenUri, a URL or any other\n     * unstructured content. Each record is identified by its recordType. We expect off-chain standardization around recordTypes and\n     * do not maintain a canonical on-chain list of records. Associated with each recordType is a content string which is intended\n     * to be interpreted by the client. The service ID must be unique and the service records must not contain duplicate record types.\n     *\n     * @param _serviceId        The service ID\n     * @param _serviceRecords   The service records\n     */\n    function createService(bytes32 _serviceId, ServiceRecord[] calldata _serviceRecords) external {\n        require(_serviceId != bytes32(0), \"Invalid ServiceId\");\n        require(!_isService(_serviceId), \"ServiceId already taken\");\n\n        serviceInfo[_serviceId].owner = msg.sender;\n\n        for (uint256 i = 0; i < _serviceRecords.length; ++i) {\n            _addServiceRecord(_serviceId, _serviceRecords[i]);\n        }\n\n        emit ServiceCreated(_serviceId, msg.sender);\n    }\n\n    /**\n     * @notice ONLY SERVICE OWNER: Adds new service records to an existing service. The service records must not contain duplicate record types or\n     * have an existing record of the same type. Don't need to explicitly check that the service has been created because if it has then there\n     * should be an owner address if not then the owner address is the zero address thus it will revert.\n     *\n     * @param _serviceId        The service ID\n     * @param _serviceRecords   The service records\n     */\n    function addServiceRecords(bytes32 _serviceId, ServiceRecord[] calldata _serviceRecords) external onlyServiceOwner(_serviceId) {\n        for (uint256 i = 0; i < _serviceRecords.length; ++i) {\n            _addServiceRecord(_serviceId, _serviceRecords[i]);\n        }\n    }\n\n    /**\n     * @notice ONLY SERVICE OWNER: Edits existing service records for an existing service. The service records must not contain duplicate record\n     * types.\n     *\n     * @param _serviceId        The service ID\n     * @param _serviceRecords   The service records\n     */\n    function editServiceRecords(bytes32 _serviceId, ServiceRecord[] calldata _serviceRecords) external onlyServiceOwner(_serviceId) {\n        bytes32[] memory recordTypes = new bytes32[](_serviceRecords.length);   // Need to do duplication check so need to store in memory\n\n        mapping(bytes32=>RecordContent) storage record = serviceRecords[_serviceId];\n        for (uint256 i = 0; i < _serviceRecords.length; ++i) {\n            // Split up the fields because it saves some gas (~100 per record)\n            bytes32 recordType = _serviceRecords[i].recordType;\n            bytes memory content = _serviceRecords[i].content;\n            bool appendId = _serviceRecords[i].appendId;\n\n            require(record[recordType].enabled, \"Record type does not exist for service\");\n\n            record[recordType].content = content;\n            record[recordType].appendId = appendId;\n            recordTypes[i] = recordType;\n\n            emit ServiceRecordEdited(_serviceId, recordType, content, appendId);\n        }\n\n        require(!recordTypes.hasDuplicate(), \"Duplicate record types\");\n    }\n\n    /**\n     * @notice ONLY SERVICE OWNER: Removes existing service records for an existing service. The service records must not contain duplicate record\n     * types.\n     *\n     * @param _serviceId        The service ID\n     * @param _recordTypes      The record types to remove\n     */\n    function removeServiceRecords(bytes32 _serviceId, bytes32[] calldata _recordTypes) external onlyServiceOwner(_serviceId) {\n        mapping(bytes32=>RecordContent) storage record = serviceRecords[_serviceId];\n        for (uint256 i = 0; i < _recordTypes.length; ++i) {\n            bytes32 recordType = _recordTypes[i];\n\n            // Case covers if record didn't exist before function call or was deleted during function call\n            require(record[recordType].enabled, \"Record type does not exist for service\");\n\n            serviceInfo[_serviceId].recordTypes.removeStorage(recordType);\n\n            delete record[recordType];\n\n            emit ServiceRecordRemoved(_serviceId, recordType);\n        }\n    }\n\n    /**\n     * @notice ONLY SERVICE OWNER: Sets the service owner to a new address. The new address cannot be the zero address.\n     *\n     * @param _serviceId        The service ID\n     * @param _newOwner         The new owner address\n     */\n    function setServiceOwner(bytes32 _serviceId, address _newOwner) external onlyServiceOwner(_serviceId) {\n        require(_newOwner != address(0), \"Invalid address\");\n        require(msg.sender != _newOwner, \"Old and new owner are same address\");     // Checked that msg.sender == oldOwner in modifier\n\n        address oldOwner = serviceInfo[_serviceId].owner;\n\n        serviceInfo[_serviceId].owner = _newOwner;\n\n        emit ServiceOwnershipTransferred(_serviceId, oldOwner, _newOwner);\n    }\n\n    /**\n     * @notice ONLY CHIP REGISTRY: Sets the initial service for a chip. The service must exist and the passed _timelock must not be 0. If the\n     * current primaryService state is set to bytes32(0) then the chip has NOT been enrolled in a service and thus this function can be called. \n     *\n     * @param _chipId           The chip ID\n     * @param _serviceId        The service ID to enroll\n     * @param _timelock         Timestamp before which the primaryService cannot be changed\n     */\n    function setInitialService(\n        address _chipId,\n        bytes32 _serviceId,\n        uint256 _timelock\n    )\n        external\n        override\n    {\n        require(msg.sender == address(chipRegistry), \"Caller must be ChipRegistry\");\n\n        // NOTE: we don't want to check that the _timelock is greater than the current timestamp in case the claim happens after timelock expires\n        require(_timelock != 0, \"Timelock cannot be set to 0\");\n        require(chipServices[_chipId].primaryService == bytes32(0), \"Primary service already set\");\n        // Covers case where _serviceId == bytes32(0) since that can't be a service per createService\n        require(_isService(_serviceId), \"Service does not exist\");\n\n        chipServices[_chipId] = ChipServices({\n            primaryService: _serviceId,\n            serviceTimelock: _timelock,\n            secondaryServices: new bytes32[](0)\n        });\n\n        emit PrimaryServiceUpdated(_chipId, _serviceId, bytes32(0), _timelock);\n    }\n\n    /**\n     * @notice ONLY CHIP OWNER: Sets the primary service for the calling chip. In order for this function to succeed the following conditions\n     * must be met:\n     *  - The caller is the chip owner\n     *  - The new service must exist\n     *  - The new service must not be the same as the current primary service\n     *  - The new timelock must be greater than the current block timestamp\n     *  - The timelock for the previous primaryService must have expired\n     *  - The new service must not be enrolled as a secondary service for the chip\n     *  - The signature was generated by the chip\n     * This function can't be called until after the chip has been claimed and enrolled in a primary service (enforced by onlyChipOwner).\n     *\n     * @param _chipId           Address of chip removing secondary service\n     * @param _serviceId        New primary service ID\n     * @param _newTimelock      Timelock for the new primary service\n     * @param _commitBlock      The block the signature is tied to (used to put a time limit on the signature)\n     * @param _signature        The signature generated by the chipId (should just be a signature of the commitBlock)\n     */\n    function setNewPrimaryService(\n        address _chipId,\n        bytes32 _serviceId,\n        uint256 _newTimelock,\n        uint256 _commitBlock,\n        bytes calldata _signature\n    )\n        external\n        onlyChipOwner(_chipId)\n    {\n        bytes32 oldPrimaryService = chipServices[_chipId].primaryService;\n\n        require(chipServices[_chipId].serviceTimelock < block.timestamp, \"Timelock has not expired\");\n        require(_newTimelock > block.timestamp, \"Timelock must be greater than current timestamp\");\n\n        // Covers case where _serviceId == bytes32(0) since that can't be a service per createService\n        require(_isService(_serviceId), \"Service does not exist\");\n        require(!enrolledServices[_chipId][_serviceId], \"Primary service cannot be secondary service\");\n        require(_serviceId != oldPrimaryService, \"Service already set as primary service\");\n\n        bytes memory payload = abi.encodePacked(_commitBlock, _serviceId, _newTimelock);\n        _chipId.validateSignatureAndExpiration(\n            _commitBlock,\n            maxBlockWindow,\n            payload,\n            _signature\n        );\n\n        chipServices[_chipId].primaryService = _serviceId;\n        chipServices[_chipId].serviceTimelock = _newTimelock;\n\n        emit PrimaryServiceUpdated(_chipId, _serviceId, oldPrimaryService, _newTimelock);\n    }\n\n    /**\n     * @notice ONLY CHIP OWNER: Adds a secondary service for the calling chip. In order for this function to succeed the following conditions\n     * must be met:\n     *  - The caller is the chip owner\n     *  - The new service must exist\n     *  - The new service must not be enrolled as a secondary service for the chip\n     *  - The new service must not be the same as the primary service\n     *  - The signature was generated by the chip\n     * This function can't be called until after the chip has been claimed and enrolled in a primary service (enforced by onlyChipOwner).\n     *\n     * @param _chipId           Address of chip removing secondary service\n     * @param _serviceId        The service ID\n     * @param _commitBlock      The block the signature is tied to (used to put a time limit on the signature)\n     * @param _signature        The signature generated by the chipId (should just be a signature of the commitBlock)\n     */\n    function addSecondaryService(\n        address _chipId,\n        bytes32 _serviceId,\n        uint256 _commitBlock,\n        bytes calldata _signature\n    )\n        external\n        onlyChipOwner(_chipId)\n    {\n        require(_isService(_serviceId), \"Service does not exist\");\n        require(!enrolledServices[_chipId][_serviceId], \"Service already enrolled\");\n        require(_serviceId != chipServices[_chipId].primaryService, \"Service already set as primary service\");\n\n        bytes memory payload = abi.encodePacked(_commitBlock, _serviceId);\n        _chipId.validateSignatureAndExpiration(\n            _commitBlock,\n            maxBlockWindow,\n            payload,\n            _signature\n        );\n\n        chipServices[_chipId].secondaryServices.push(_serviceId);\n        enrolledServices[_chipId][_serviceId] = true;\n\n        emit SecondaryServiceAdded(_chipId, _serviceId);\n    }\n\n    /**\n     * @notice ONLY CHIP OWNER: Removes a secondary service for the calling chip. In order for this function to succeed the following\n     * conditions must be met:\n     *  - The caller is the chip owner\n     *  - The service must exist\n     *  - The service must be enrolled as a secondary service for the chip\n     *  - The signature was generated by the chip\n     * This function can't be called until after the chip has been claimed and enrolled in a primary service (enforced by onlyChipOwner).\n     *\n     * @param _chipId           Address of chip removing secondary service\n     * @param _serviceId        The service ID\n     * @param _commitBlock      The block the signature is tied to (used to put a time limit on the signature)\n     * @param _signature        The signature generated by the chipId (should just be a signature of the commitBlock)\n     */\n    function removeSecondaryService(\n        address _chipId,\n        bytes32 _serviceId,\n        uint256 _commitBlock,\n        bytes calldata _signature\n    )\n        external\n        onlyChipOwner(_chipId)\n    {\n        require(_isService(_serviceId), \"Service does not exist\");\n        require(enrolledServices[_chipId][_serviceId], \"Service not enrolled\");\n\n        bytes memory payload = abi.encodePacked(_commitBlock, _serviceId);\n        _chipId.validateSignatureAndExpiration(\n            _commitBlock,\n            maxBlockWindow,\n            payload,\n            _signature\n        );\n\n        chipServices[_chipId].secondaryServices.removeStorage(_serviceId);\n        enrolledServices[_chipId][_serviceId] = false;\n\n        emit SecondaryServiceRemoved(_chipId, _serviceId);\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     * Return information about owner and record types for a service\n     *\n     * @param _serviceId        The service ID\n     * @return                  ServiceInfo struct (owner and recordTypes)\n     */\n    function getServiceInfo(bytes32 _serviceId) external view returns (ServiceInfo memory) {\n        return serviceInfo[_serviceId];\n    }\n\n    /**\n     * Get the content of the given record type for a chip's primary service\n     *\n     * @param _chipId        The chip ID\n     * @param _recordType    The record type\n     * @return               bytes representing the content of the record\n     */\n    function getPrimaryServiceContentByRecordtype(\n        address _chipId,\n        bytes32 _recordType\n    )\n        external\n        view\n        override\n        returns (bytes memory)\n    {\n        bytes32 primaryService = chipServices[_chipId].primaryService;\n        RecordContent memory recordContent = serviceRecords[primaryService][_recordType];\n        return _createContentString(_chipId, recordContent.content, recordContent.appendId);\n    }\n\n    /**\n     * Get a list of all records for a given service\n     *\n     * @param _serviceId     The service ID\n     * @return records       List of ServiceRecords for the passed serviceId\n     */\n    function getServiceContent(address _chipId, bytes32 _serviceId) public view returns (Record[] memory records) {\n        bytes32[] memory recordTypes = serviceInfo[_serviceId].recordTypes;\n\n        uint256 recordTypesLength = recordTypes.length;\n        records = new Record[](recordTypesLength);\n        for (uint256 i = 0; i < recordTypesLength; ++i) {\n            bytes32 recordType = recordTypes[i];\n            RecordContent memory serviceContent = serviceRecords[_serviceId][recordType];\n            records[i] = Record({\n                recordType: recordType,\n                content: _createContentString(_chipId, serviceContent.content, serviceContent.appendId)\n            });\n        }\n    }\n\n    /**\n     * Get records for every secondary service and primary service for a chip. Primary service timelock is also included\n     * in struct.\n     *\n     * @param _chipId   The chip ID\n     * @return          Struct containing all records for each secondary service and primary service for the chip\n     */\n    function getAllChipServiceData(address _chipId) external view returns (ExpandedChipServices memory) {\n        bytes32 primaryService = chipServices[_chipId].primaryService;\n        bytes32[] memory secondaryServices = getChipSecondaryServices(_chipId);\n\n        uint256 servicesArrayLength = secondaryServices.length;\n        Service[] memory services = new Service[](servicesArrayLength);\n        for (uint256 i = 0; i < servicesArrayLength; ++i) {\n            bytes32 serviceId = secondaryServices[i];\n            Record[] memory records = getServiceContent(_chipId, serviceId);\n            services[i] = Service({\n                serviceId: serviceId,\n                records: records\n            });\n        }\n\n        return ExpandedChipServices({\n            primaryService: Service({\n                serviceId: primaryService,\n                records: getServiceContent(_chipId, primaryService)\n            }),\n            serviceTimelock: chipServices[_chipId].serviceTimelock,\n            secondaryServices: services\n        });\n    }\n\n    /**\n     * Get records for every secondary service and primary service for a chip. Primary service timelock is also included\n     * in struct.\n     *\n     * @param _chipId   The chip ID\n     * @return          List of ServiceRecords for the chip's primary service\n     */\n    function getPrimaryServiceContent(address _chipId) external view returns (Record[] memory) {\n        bytes32 primaryService = chipServices[_chipId].primaryService;\n        return getServiceContent(_chipId, primaryService);\n    }\n\n    /**\n     * Get list of secondary service Id's for a chip\n     *\n     * @param _chipId   The chip ID\n     * @return          List of secondary serviceIds for the chip\n     */\n    function getChipSecondaryServices(address _chipId) public view returns (bytes32[] memory) {\n        return chipServices[_chipId].secondaryServices;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Adds a new service record to an existing service. The service records must not contain duplicate record types or\n     * have an existing record of the same type.\n     *\n     * @param _serviceId        The service ID\n     * @param _record           ServiceRecord struct containing recordType, content, and appendId\n     */\n    function _addServiceRecord(bytes32 _serviceId, ServiceRecord calldata _record) internal {\n        // Case covers if record was previously added before function call or during function call\n        require(!serviceRecords[_serviceId][_record.recordType].enabled, \"Record type already exists for service\");\n\n        serviceRecords[_serviceId][_record.recordType] = RecordContent({\n            enabled: true,\n            content: _record.content,\n            appendId: _record.appendId\n        });\n\n        serviceInfo[_serviceId].recordTypes.push(_record.recordType);\n\n        emit ServiceRecordAdded(_serviceId, _record.recordType, _record.content, _record.appendId);\n    }\n\n    /**\n     * @notice Checks if a service exists\n     *\n     * @param _serviceId        The service ID\n     * @return                  True if service exists, false otherwise\n     */\n    function _isService(bytes32 _serviceId) internal view returns (bool) {\n        return serviceInfo[_serviceId].owner != address(0);\n    }\n\n    /**\n     * @notice Build a content string based on if the chipId should be appended to the base content\n     *\n     * @param _chipId           The chip ID\n     * @param _content          The base content\n     * @param _appendId         Whether or not to append the chipId to the content\n     * @return                  Bytestring representing the content\n     */\n    function _createContentString(address _chipId, bytes memory _content, bool _appendId) internal pure returns (bytes memory) {\n        // Must convert to string first then to bytes otherwise interpreters will try to convert address to a utf8 string\n        string memory stringChipId = Strings.toHexString(_chipId);\n        return _appendId ? bytes.concat(_content, bytes(stringChipId)) : _content;\n    }\n}\n"
    },
    "contracts/token/ClaimedPBT.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { ERC721 } from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n\nimport { ChipValidations } from \"../lib/ChipValidations.sol\";\nimport { ERC721ReadOnly } from \"./ERC721ReadOnly.sol\";\nimport { IPBT } from \"./IPBT.sol\";\nimport { ITransferPolicy } from \"../interfaces/ITransferPolicy.sol\";\n\n\n/**\n * @title ClaimedPBT\n * @author Arx\n *\n * @notice Implementation of PBT where tokenIds are assigned to chip addresses as the chips are claimed by their owners. Each chip has its own\n * transfer policy, which can be set by the chip owner and allows the owner to specify how the chip can be transferred to another party. This\n * enables more flexibility for secondary services to facilitate the transfer of chips. Additionally, chip owners can directly transfer their\n * chips by calling setOwner, this function is only callable by the chip owner whereas the transfer function is callable by anyone (assuming\n * transfer policy conditions have been met). Since there is often other metadata associated with a chip we provide a tokenData field that can\n * be written to by inheriting contracts.\n */\ncontract ClaimedPBT is IPBT, ERC721ReadOnly {\n    using SignatureChecker for address;\n    using ChipValidations for address;\n    using ECDSA for bytes;\n    using ECDSA for bytes32;\n\n    /* ============ Events ============ */\n\n    event TransferPolicyChanged(address indexed chipId, address transferPolicy);    // Emitted in setTransferPolicy\n    \n    /* ============ Structs ============ */\n\n    // tokenData is a byte array that can be used to store any data that an inheriting contract may need for its logic.\n    // Inheriting contract is responsible for encoding/decoding the data.\n    struct ChipInfo {\n        uint256 tokenId;\n        ITransferPolicy transferPolicy;\n        string tokenUri;\n        bytes tokenData;\n    }\n\n    /* ============ Modifiers ============ */\n\n    modifier onlyChipOwner(address _chipId) {\n        require(ownerOf(chipTable[_chipId].tokenId) == msg.sender, \"Caller must be chip owner\");\n        _;\n    }\n\n    modifier onlyClaimedChip(address _chipId) {\n        require(_exists(_chipId), \"Chip must be claimed\");\n        _;\n    }\n    \n    /* ============ State Variables ============ */\n    uint256 public immutable maxBlockWindow;            // Amount of blocks from commitBlock after which chip signatures are expired\n    mapping(address=>ChipInfo) public chipTable;        // Maps a chipId to a ChipInfo struct\n\n    mapping(uint256=>address) public tokenIdToChipId;   // Maps an ERC-721 token ID to a chipId\n    uint256 public tokenIdCounter;                      // Counter for ERC-721 token IDs\n\n    /* ============ Constructor ============ */\n\n    /**\n     * @dev Constructor for ClaimedPBT. Sets the name and symbol for the token.\n     *\n     * @param _name             The name of the token\n     * @param _symbol           The symbol of the token\n     * @param _maxBlockWindow   The maximum amount of blocks a signature used for updating chip table is valid for\n     */\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _maxBlockWindow\n    )\n        ERC721ReadOnly(_name, _symbol)\n    {\n        tokenIdCounter = 1;         // The zeroth chipId is reserved for checking if chip is claimed\n        maxBlockWindow = _maxBlockWindow;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice Included for compliance with EIP-5791 standard but left unimplemented to ensure transfer policies can't be ignored.\n     */\n    function transferTokenWithChip(\n        bytes calldata /*signatureFromChip*/,\n        uint256 /*blockNumberUsedInSig*/,\n        bool /*useSafeTransfer*/\n    )\n        public\n        virtual\n    {\n        revert(\"Not implemented\");\n    }\n\n    /**\n     * @notice Allow a user to transfer a chip to a new owner with additional checks. A transfer policy must be set in order for\n     * transfer to go through. The data contained in _payload will be dependent on the implementation of the transfer policy, however\n     * the signature should be signed by the chip. EIP-1271 compatibility should be implemented in the chip's TransferPolicy contract.\n     *\n     * @param chipId                Chip ID (address) of chip being transferred\n     * @param signatureFromChip     Signature of keccak256(msg.sender, blockhash(blockNumberUsedInSig), _payload) signed by chip\n     *                              being transferred\n     * @param blockNumberUsedInSig  Block number used in signature\n     * @param useSafeTransfer       Indicates whether to use safeTransferFrom or transferFrom\n     * @param payload               Encoded payload containing data required to execute transfer. Data structure will be dependent\n     *                              on implementation of TransferPolicy\n     */\n    function transferToken(\n        address chipId,\n        bytes calldata signatureFromChip,\n        uint256 blockNumberUsedInSig,\n        bool useSafeTransfer,\n        bytes calldata payload\n    ) \n        public\n        virtual\n        onlyClaimedChip(chipId)\n    {\n        ChipInfo memory chipInfo = chipTable[chipId];\n        address chipOwner = ownerOf(chipInfo.tokenId);\n        \n        require(chipInfo.transferPolicy != ITransferPolicy(address(0)), \"Transfer policy must be set\");\n\n        // Check that the signature is valid, create own scope to prevent stack-too-deep error\n        {\n            bytes32 signedHash = _createSignedHash(blockNumberUsedInSig, payload);\n            require(chipId.isValidSignatureNow(signedHash, signatureFromChip), \"Invalid signature\");\n        }\n\n        _transferPBT(chipOwner, chipInfo.tokenId, useSafeTransfer);\n\n        // Validation of the payload beyond ensuring it was signed by the chip is left up to the TransferPolicy contract.\n        //authorizeTransfer(address _chipId, address _sender, address _chipOwner, bytes _payload, bytes _signature)\n        chipInfo.transferPolicy.authorizeTransfer(\n            chipId,\n            msg.sender,\n            chipOwner,\n            payload,\n            signatureFromChip\n        );\n    }\n\n    /**\n     * @dev ONLY CHIP OWNER: Sets the transfer policy for a chip. Chip owner must submit transaction along with\n     * a signature from the chipId commiting to a block the signature was generated. This is to prevent any\n     * replay attacks. If the transaction isn't submitted within the MAX_BLOCK_WINDOW from the commited block\n     * this function will revert.\n     *\n     * @param _chipId           The chipId to set the transfer policy for\n     * @param _newPolicy        The address of the new transfer policy. We allow the zero address in case owner doesn't want to allow xfers.\n     * @param _commitBlock      The block the signature is tied to (used to put a time limit on the signature)\n     * @param _signature        The signature generated by the chipId (should just be a signature of the commitBlock)\n     */\n    function setTransferPolicy(\n        address _chipId,\n        ITransferPolicy _newPolicy,\n        uint256 _commitBlock,\n        bytes calldata _signature\n    )\n        public\n        virtual\n        onlyChipOwner(_chipId)\n    {\n        // Check that the signature is valid for the payload\n        _chipId.validateSignatureAndExpiration(\n            _commitBlock,\n            maxBlockWindow,\n            abi.encodePacked(_commitBlock, _newPolicy),     // Formulate the payload\n            _signature\n        );\n\n        // Set the transfer policy\n        chipTable[_chipId].transferPolicy = _newPolicy;\n\n        emit TransferPolicyChanged(_chipId, address(_newPolicy));\n    }\n\n    /**\n     * @dev ONLY CHIP OWNER: Sets the owner for a chip. Chip owner must submit transaction along with\n     * a signature from the chipId commiting to a block the signature was generated. This is to prevent any\n     * replay attacks. If the transaction isn't submitted within the MAX_BLOCK_WINDOW from the commited block\n     * this function will revert.\n     *\n     * @param _chipId           The chipId to set the owner for\n     * @param _newOwner         The address of the new chip owner\n     * @param _commitBlock      The block the signature is tied to (used to put a time limit on the signature)\n     * @param _signature        The signature generated by the chipId (should just be a signature of the commitBlock)\n     */\n    function setOwner(\n        address _chipId,\n        address _newOwner,\n        uint256 _commitBlock,\n        bytes calldata _signature\n    )\n        public\n        virtual\n        onlyChipOwner(_chipId)\n    {\n        // Check that the signature is valid for the payload\n        _chipId.validateSignatureAndExpiration(\n            _commitBlock,\n            maxBlockWindow,\n            abi.encodePacked(_commitBlock, _newOwner),  // Formulate the payload\n            _signature\n        );\n\n        // Set the new owner\n        _transfer(msg.sender, _newOwner, tokenIdFor(_chipId));\n    }\n\n    /* ============ View Functions ============ */\n\n    /**\n     * @dev Using OpenZeppelin's SignatureChecker library, checks if the signature is valid for the payload. Library is\n     * ERC-1271 compatible, so it will check if the chipId is a contract and if so, if it implements the isValidSignature.\n     *\n     * @param _chipId       The chipId to check the signature for\n     * @param _payload      The payload to check the signature for\n     * @param _signature    The signature to check\n     * @return bool         If the signature is valid, false otherwise\n     */\n    function isChipSignatureForToken(address _chipId, bytes calldata _payload, bytes calldata _signature)\n        public\n        view\n        returns (bool)\n    {\n        bytes32 _payloadHash = abi.encodePacked(_payload).toEthSignedMessageHash();\n        return _chipId.isValidSignatureNow(_payloadHash, _signature);\n    }\n\n    /**\n     * @dev Returns the tokenURI for a given tokenId. Token must have been minted / chip claimed.\n     *\n     * @param _tokenId      The tokenId to get the tokenURI for\n     * @return string       The tokenURI for the given tokenId\n     */\n    function tokenURI(\n        uint256 _tokenId\n    )\n        public\n        view\n        virtual\n        override(IERC721Metadata, ERC721)\n        returns (string memory)\n    {\n        _requireMinted(_tokenId);\n        return chipTable[tokenIdToChipId[_tokenId]].tokenUri;\n    }\n\n    /**\n     * @dev Returns the tokenURI for a given chipId. Chip must have been claimed / token minted.\n     *\n     * @param _chipId      The tokenId to get the tokenURI for\n     * @return string       The tokenURI for the given tokenId\n     */\n    function tokenURI(address _chipId) public view virtual onlyClaimedChip(_chipId) returns (string memory) {\n        return chipTable[_chipId].tokenUri;\n    }\n\n    /**\n     * @dev Returns the tokenId for a given chipId\n     *\n     * @param _chipId       The chipId to get the tokenId for\n     * @return tokenId      The tokenId for the given chipId\n     */\n    function tokenIdFor(address _chipId) public view returns (uint256 tokenId) {\n        tokenId = chipTable[_chipId].tokenId;\n        require(tokenId != 0, \"Chip must be claimed\");\n    }\n\n    /**\n     * @dev Returns the owner of a given chipId\n     *\n     * @param _chipId       The chipId to get the owner for\n     * @return address      The owner of the given chipId\n     */\n    function ownerOf(address _chipId) public view override returns (address) {\n        return ownerOf(tokenIdFor(_chipId));\n    }\n\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(ERC721, IERC165)\n        returns (bool)\n    {\n        return _interfaceId == type(IPBT).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @dev Mints a new token and assigns it to the given address. Also adds the chipId to the tokenIdToChipId mapping,\n     * adds the ChipInfo to the chipTable, and increments the tokenIdCounter.\n     *\n     * @param _to           The address to mint the token to\n     * @param _chipId       The chipId to mint the token for\n     * @param _chipInfo     The ChipInfo struct to add to the chipTable (tokenId is modified in this function)\n     * @return uint256      The tokenId of the newly minted token\n     */\n    function _mint(\n        address _to,\n        address _chipId,\n        ChipInfo memory  _chipInfo\n    )\n        internal\n        virtual\n        returns(uint256)\n    {\n        uint256 tokenId = tokenIdCounter++;\n        super._mint(_to, tokenId);\n        \n        tokenIdToChipId[tokenId] = _chipId;\n        \n        _chipInfo.tokenId = tokenId;\n        chipTable[_chipId] = _chipInfo;\n\n        emit PBTMint(tokenId, _chipId);\n        return tokenId;\n    }\n\n    function _createSignedHash(\n        uint256 _blockNumberUsedInSig,\n        bytes memory _customPayload\n    )\n        internal\n        virtual\n        returns (bytes32)\n    {\n        // The blockNumberUsedInSig must be in a previous block because the blockhash of the current\n        // block does not exist yet.\n        require(block.number >= _blockNumberUsedInSig, \"Block number must have been mined\");\n        require(block.number - _blockNumberUsedInSig <= maxBlockWindow, \"Block number must be within maxBlockWindow\");\n\n        return abi.encodePacked(msg.sender, blockhash(_blockNumberUsedInSig), _customPayload).toEthSignedMessageHash();\n    }\n\n    /**\n     * @notice Handle transfer of PBT inclusing whether to transfer using safeTransfer. The _to address is always the msg.sender.\n     *\n     * @param _from                 Address of owner transferring PBT\n     * @param _tokenId              ID of PBT being transferred\n     * @param _useSafeTransfer      Indicates whether to use safeTransferFrom or transferFrom\n     */\n    function _transferPBT(address _from, uint256 _tokenId, bool _useSafeTransfer) internal {\n        if (_useSafeTransfer) {\n            _safeTransfer(_from, msg.sender, _tokenId, \"\");\n        } else {\n            _transfer(_from, msg.sender, _tokenId);\n        }\n    }\n\n    /**\n     * @dev Indicates whether the chipId has been claimed or not\n     *\n     * @param _chipId       The chipId to check\n     * @return bool         True if the chipId has been claimed, false otherwise\n     */\n    function _exists(address _chipId) internal view returns (bool) {\n        return chipTable[_chipId].tokenId != 0;\n    }\n}\n"
    },
    "contracts/token/ERC721ReadOnly.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n/**\n * @notice An implementation of 721 that's publicly readonly (no approvals or transfers exposed).\n */\n\ncontract ERC721ReadOnly is ERC721 {\n    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}\n\n    function approve(address /*to*/, uint256 /*tokenId*/) public virtual override {\n        revert(\"ERC721 public approve not allowed\");\n    }\n\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n        return address(0);\n    }\n\n    function setApprovalForAll(address /*operator*/, bool /*approved*/) public virtual override {\n        revert(\"ERC721 public setApprovalForAll not allowed\");\n    }\n\n    function isApprovedForAll(address /*owner*/, address /*operator*/) public view virtual override returns (bool) {\n        return false;\n    }\n\n    function transferFrom(address /*from*/, address /*to*/, uint256 /*tokenId*/) public virtual override {\n        revert(\"ERC721 public transferFrom not allowed\");\n    }\n\n    function safeTransferFrom(address /*from*/, address /*to*/, uint256 /*tokenId*/) public virtual override {\n        revert(\"ERC721 public safeTransferFrom not allowed\");\n    }\n\n    function safeTransferFrom(address /*from*/, address /*to*/, uint256 /*tokenId*/, bytes memory /*data*/) public virtual override {\n        revert(\"ERC721 public safeTransferFrom not allowed\");\n    }\n}\n"
    },
    "contracts/token/IPBT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\n/**\n * @dev Contract for PBTs (Physical Backed Tokens).\n * NFTs that are backed by a physical asset, through a chip embedded in the physical asset.\n */\n\ninterface IPBT is IERC721Metadata {\n\n    function tokenIdFor(address chipAddress) external view returns (uint256);\n\n    function isChipSignatureForToken(address chipId, bytes calldata payload, bytes calldata signature)\n        external\n        view\n        returns (bool);\n\n    function transferTokenWithChip(\n        bytes calldata signatureFromChip,\n        uint256 blockNumberUsedInSig,\n        bool useSafeTransferFrom\n    )\n        external;\n\n    function transferToken(\n        address chipId,\n        bytes calldata signatureFromChip,\n        uint256 blockNumberUsedInSig,\n        bool useSafeTransferFrom,\n        bytes calldata payload\n    ) external;\n\n    function ownerOf(address _chipId) external view returns (address);\n\n    /// @notice Emitted when a token is minted.\n    event PBTMint(uint256 indexed tokenId, address indexed chipAddress);\n\n    /// @notice Emitted when a token is mapped to a different chip.\n    /// Chip replacements may be useful in certain scenarios (e.g. chip defect).\n    event PBTChipRemapping(uint256 indexed tokenId, address indexed oldChipAddress, address indexed newChipAddress);\n}\n"
    },
    "contracts/token/transfer-policies/OpenTransferPolicy.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport { ITransferPolicy } from \"../../interfaces/ITransferPolicy.sol\";\n\n/**\n * @title OpenTransferPolicy\n * @dev This transfer policy performs no checks and creates parity with the PBT standard\n * transferTokenWithChip function. TransferPolicy is necessary because the ChipRegistry does\n * not support transferTokenWithChip so that transferToken cannot be overridden.\n */\ncontract OpenTransferPolicy is ITransferPolicy {\n\n    /* ============ Constructor ============ */\n\n    constructor() {}\n    \n    /* ============ External Functions ============ */\n    /**\n      * @notice This function enforces no additional checks and allows the transfer to proceed\n      * for parity with transferTokenWithChip function in PBT standard.\n      */\n    function authorizeTransfer(\n        address /*_chipId*/,\n        address /*_sender*/,\n        address /*_chipOwner*/,\n        bytes calldata /*_payload*/,\n        bytes calldata /*_signature*/\n    )\n        external\n        override\n    {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}